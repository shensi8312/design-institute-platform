# Wordæ¨¡æ¿ç¼–è¾‘å™¨åŠŸèƒ½å¢å¼ºæ–¹æ¡ˆ

## ğŸ“‹ éœ€æ±‚åˆ†æ

### å½“å‰çŠ¶æ€
- âœ… æ¨¡æ¿ç®¡ç†é¡µé¢ï¼šä¸Šä¼ ã€åˆ—è¡¨ã€å‘å¸ƒã€åˆ é™¤åŠŸèƒ½å®Œå–„
- âœ… æ¨¡æ¿ç¼–è¾‘å™¨ï¼šä½¿ç”¨OnlyOfficeï¼Œä½†ä»…æ˜¯å•çº¯çš„Wordç¼–è¾‘å™¨
- âŒ **ç¼ºå¤±**ï¼šå·¦ä¾§ç›®å½•å¤§çº²ã€ç« èŠ‚è·³è½¬ã€å¯¼å‡ºåŠŸèƒ½

### ç”¨æˆ·éœ€æ±‚
1. **å·¦ä¾§æ˜¾ç¤ºç›®å½•**ï¼šæå–Wordæ–‡æ¡£çš„å¤§çº²ç»“æ„ï¼ˆæ ‡é¢˜å±‚çº§ï¼‰
2. **å³ä¾§ç¼–è¾‘å™¨**ï¼šä¿æŒWordåŸæ ¼å¼ï¼Œå¯ç¼–è¾‘
3. **ç›®å½•äº¤äº’**ï¼šç‚¹å‡»ç›®å½•é¡¹è·³è½¬åˆ°å¯¹åº”ç« èŠ‚
4. **ä¿å­˜åŠŸèƒ½**ï¼šç¼–è¾‘åè‡ªåŠ¨ä¿å­˜
5. **å¯¼å‡ºåŠŸèƒ½**ï¼šå¯¼å‡ºä¸ºWordæ–‡æ¡£

---

## ğŸ—ï¸ æŠ€æœ¯æ–¹æ¡ˆ

### æ¶æ„è®¾è®¡

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          TemplateEditor (å®¹å™¨ç»„ä»¶)                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  å·¦ä¾§ (25%)      â”‚      å³ä¾§ (75%)               â”‚
â”‚                  â”‚                                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  ç›®å½•æ ‘    â”‚ â”‚  â”‚   OnlyOffice ç¼–è¾‘å™¨       â”‚ â”‚
â”‚  â”‚            â”‚ â”‚  â”‚                           â”‚ â”‚
â”‚  â”‚  1. æ€»åˆ™   â”‚ â”‚  â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚ â”‚
â”‚  â”‚  2. æœ¯è¯­   â”‚ â”‚  â”‚   â”‚ Word æ–‡æ¡£å†…å®¹    â”‚   â”‚ â”‚
â”‚  â”‚  3. æŠ€æœ¯   â”‚ â”‚  â”‚   â”‚  (ä¿æŒåŸæ ¼å¼)    â”‚   â”‚ â”‚
â”‚  â”‚    3.1...  â”‚â—„â”€â”¼â”€â”€â”¼â”€â”€â”€â–º å¯ç¼–è¾‘          â”‚   â”‚ â”‚
â”‚  â”‚    3.2...  â”‚ â”‚  â”‚   â”‚  è‡ªåŠ¨ä¿å­˜        â”‚   â”‚ â”‚
â”‚  â”‚  4. è´¨é‡   â”‚ â”‚  â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â†“ APIè°ƒç”¨               â†“ OnlyOffice API
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  è·å–ç›®å½•ç»“æ„ â”‚        â”‚   æ–‡æ¡£ç¼–è¾‘/ä¿å­˜   â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ”§ å®ç°æ­¥éª¤

### é˜¶æ®µ1ï¼šåç«¯ - Wordç›®å½•æå– â­

#### 1.1 å®‰è£…ä¾èµ–åŒ…

```bash
cd apps/api
npm install mammoth docx --save
```

**åŒ…è¯´æ˜**ï¼š
- `mammoth`: å°†Wordæ–‡æ¡£è½¬æ¢ä¸ºHTMLï¼Œæå–å†…å®¹
- `docx`: è§£æ.docxæ–‡ä»¶ç»“æ„ï¼Œæå–æ ·å¼å’Œæ ¼å¼

#### 1.2 å®ç°Wordè§£ææœåŠ¡

**æ–‡ä»¶**: `apps/api/src/services/document/WordOutlineExtractor.js`

```javascript
const mammoth = require('mammoth');
const fs = require('fs').promises;

/**
 * Wordæ–‡æ¡£å¤§çº²æå–å™¨
 * æå–æ ‡é¢˜å±‚çº§ç»“æ„
 */
class WordOutlineExtractor {
  /**
   * ä»Wordæ–‡ä»¶æå–ç›®å½•å¤§çº²
   * @param {string} filePath - Wordæ–‡ä»¶è·¯å¾„
   * @returns {Promise<Array>} ç›®å½•ç»“æ„æ•°ç»„
   */
  async extractOutline(filePath) {
    try {
      // è¯»å–Wordæ–‡ä»¶
      const buffer = await fs.readFile(filePath);

      // ä½¿ç”¨mammothæå–HTMLå’Œæ ·å¼
      const result = await mammoth.convertToHtml(
        { buffer },
        {
          styleMap: [
            // æ˜ å°„Wordæ ‡é¢˜æ ·å¼åˆ°HTMLæ ‡ç­¾
            "p[style-name='Heading 1'] => h1:fresh",
            "p[style-name='Heading 2'] => h2:fresh",
            "p[style-name='Heading 3'] => h3:fresh",
            "p[style-name='Heading 4'] => h4:fresh",
            "p[style-name='æ ‡é¢˜ 1'] => h1:fresh",
            "p[style-name='æ ‡é¢˜ 2'] => h2:fresh",
            "p[style-name='æ ‡é¢˜ 3'] => h3:fresh",
            "p[style-name='æ ‡é¢˜ 4'] => h4:fresh",
          ]
        }
      );

      // è§£æHTMLæå–æ ‡é¢˜
      const outline = this._parseHtmlToOutline(result.value);

      return outline;
    } catch (error) {
      console.error('[Wordè§£æ] æå–å¤§çº²å¤±è´¥:', error);
      throw new Error(`è§£æWordæ–‡ä»¶å¤±è´¥: ${error.message}`);
    }
  }

  /**
   * ä»HTMLæå–æ ‡é¢˜ç»“æ„
   * @private
   */
  _parseHtmlToOutline(html) {
    const headingRegex = /<h([1-4])[^>]*>(.*?)<\/h\1>/gi;
    const outline = [];
    const stack = [{ level: 0, children: outline }];

    let match;
    let order = 0;

    while ((match = headingRegex.exec(html)) !== null) {
      const level = parseInt(match[1]);
      const title = match[2].replace(/<[^>]+>/g, '').trim(); // ç§»é™¤HTMLæ ‡ç­¾

      // è·³è¿‡ç©ºæ ‡é¢˜
      if (!title) continue;

      const node = {
        id: `heading_${order}`,
        title,
        level,
        order: order++,
        children: []
      };

      // æ‰¾åˆ°åˆé€‚çš„çˆ¶èŠ‚ç‚¹
      while (stack.length > 1 && stack[stack.length - 1].level >= level) {
        stack.pop();
      }

      // æ·»åŠ åˆ°çˆ¶èŠ‚ç‚¹çš„children
      stack[stack.length - 1].children.push(node);

      // å½“å‰èŠ‚ç‚¹å…¥æ ˆ
      stack.push(node);
    }

    return outline;
  }

  /**
   * ç”Ÿæˆæ‰å¹³åŒ–çš„ç›®å½•åˆ—è¡¨ï¼ˆç”¨äºAPIè¿”å›ï¼‰
   * @param {Array} outline - æ ‘å½¢ç›®å½•ç»“æ„
   * @returns {Array} æ‰å¹³åŒ–æ•°ç»„
   */
  flattenOutline(outline) {
    const flat = [];

    const traverse = (nodes, depth = 0, parentPath = []) => {
      nodes.forEach((node, index) => {
        const path = [...parentPath, index + 1];
        flat.push({
          ...node,
          depth,
          path: path.join('.'),
          hasChildren: node.children && node.children.length > 0
        });

        if (node.children && node.children.length > 0) {
          traverse(node.children, depth + 1, path);
        }
      });
    };

    traverse(outline);
    return flat;
  }
}

module.exports = new WordOutlineExtractor();
```

#### 1.3 æ›´æ–°TemplateService

**æ–‡ä»¶**: `apps/api/src/services/document/TemplateService.js`

åœ¨ `_parseTemplateFile` æ–¹æ³•ä¸­è°ƒç”¨æ–°çš„æå–å™¨ï¼š

```javascript
const WordOutlineExtractor = require('./WordOutlineExtractor');

async _parseTemplateFile(filePath, templateType) {
  try {
    // æå–Wordæ–‡æ¡£ç›®å½•ç»“æ„
    const outline = await WordOutlineExtractor.extractOutline(filePath);
    const flatOutline = WordOutlineExtractor.flattenOutline(outline);

    return {
      sectionStructure: outline,      // æ ‘å½¢ç»“æ„
      flatSections: flatOutline,      // æ‰å¹³ç»“æ„
      variables: [],
      config: {}
    };
  } catch (error) {
    console.error('[æ¨¡æ¿è§£æ] å¤±è´¥:', error);
    // è¿”å›ç©ºç»“æ„ï¼Œä¸å½±å“æ¨¡æ¿åˆ›å»º
    return {
      sectionStructure: [],
      flatSections: [],
      variables: [],
      config: {}
    };
  }
}
```

#### 1.4 æ·»åŠ APIç«¯ç‚¹

**æ–‡ä»¶**: `apps/api/src/routes/unifiedDocument.js`

æ·»åŠ è·å–æ¨¡æ¿ç›®å½•çš„APIï¼š

```javascript
/**
 * è·å–æ¨¡æ¿çš„ç›®å½•ç»“æ„
 * GET /api/unified-document/templates/:id/outline
 */
router.get('/templates/:id/outline', authenticate, async (req, res) => {
  try {
    const { id } = req.params;

    const template = await knex('document_templates')
      .where({ id })
      .first();

    if (!template) {
      return res.status(404).json({
        success: false,
        message: 'æ¨¡æ¿ä¸å­˜åœ¨'
      });
    }

    // ä»configä¸­è¯»å–è§£æå¥½çš„ç›®å½•ç»“æ„
    const config = JSON.parse(template.config || '{}');

    res.json({
      success: true,
      data: {
        outline: config.sectionStructure || [],
        flatOutline: config.flatSections || []
      }
    });
  } catch (error) {
    console.error('[æ¨¡æ¿ç®¡ç†] è·å–ç›®å½•å¤±è´¥:', error);
    res.status(500).json({
      success: false,
      message: 'è·å–æ¨¡æ¿ç›®å½•å¤±è´¥',
      error: error.message
    });
  }
});
```

---

### é˜¶æ®µ2ï¼šå‰ç«¯ - å·¦å³åˆ†æ ç¼–è¾‘å™¨ â­â­

#### 2.1 åˆ›å»ºç›®å½•æ ‘ç»„ä»¶

**æ–‡ä»¶**: `apps/web/src/components/TemplateOutlineTree.tsx`

```typescript
import React, { useState, useEffect } from 'react';
import { Tree, Input, Space, Spin } from 'antd';
import { SearchOutlined, FolderOutlined, FileTextOutlined } from '@ant-design/icons';
import type { DataNode } from 'antd/es/tree';
import axios from '../utils/axios';

interface OutlineNode {
  id: string;
  title: string;
  level: number;
  order: number;
  children?: OutlineNode[];
}

interface Props {
  templateId: string;
  onSelectNode?: (node: OutlineNode) => void;
}

const TemplateOutlineTree: React.FC<Props> = ({ templateId, onSelectNode }) => {
  const [outline, setOutline] = useState<OutlineNode[]>([]);
  const [loading, setLoading] = useState(true);
  const [searchValue, setSearchValue] = useState('');
  const [expandedKeys, setExpandedKeys] = useState<string[]>([]);

  useEffect(() => {
    loadOutline();
  }, [templateId]);

  const loadOutline = async () => {
    setLoading(true);
    try {
      const response = await axios.get(
        `/api/unified-document/templates/${templateId}/outline`
      );

      if (response.data.success) {
        setOutline(response.data.data.outline);
        // é»˜è®¤å±•å¼€ç¬¬ä¸€å±‚
        const firstLevelKeys = response.data.data.outline.map((n: OutlineNode) => n.id);
        setExpandedKeys(firstLevelKeys);
      }
    } catch (error: any) {
      console.error('åŠ è½½ç›®å½•å¤±è´¥:', error);
    } finally {
      setLoading(false);
    }
  };

  // è½¬æ¢ä¸ºAntd Treeæ‰€éœ€çš„æ•°æ®æ ¼å¼
  const convertToTreeData = (nodes: OutlineNode[]): DataNode[] => {
    return nodes.map((node) => ({
      key: node.id,
      title: (
        <span style={{ fontSize: 14 }}>
          {node.title}
        </span>
      ),
      icon: node.children?.length ? <FolderOutlined /> : <FileTextOutlined />,
      children: node.children ? convertToTreeData(node.children) : undefined,
    }));
  };

  // è¿‡æ»¤æœç´¢
  const filterTree = (nodes: OutlineNode[], searchTerm: string): OutlineNode[] => {
    return nodes.filter((node) => {
      const matchTitle = node.title.toLowerCase().includes(searchTerm.toLowerCase());
      const matchChildren = node.children
        ? filterTree(node.children, searchTerm).length > 0
        : false;
      return matchTitle || matchChildren;
    }).map((node) => ({
      ...node,
      children: node.children ? filterTree(node.children, searchTerm) : undefined,
    }));
  };

  const displayOutline = searchValue
    ? filterTree(outline, searchValue)
    : outline;

  const treeData = convertToTreeData(displayOutline);

  const handleSelect = (selectedKeys: React.Key[], info: any) => {
    if (selectedKeys.length > 0 && onSelectNode) {
      // æ‰¾åˆ°é€‰ä¸­çš„èŠ‚ç‚¹
      const findNode = (nodes: OutlineNode[], key: string): OutlineNode | null => {
        for (const node of nodes) {
          if (node.id === key) return node;
          if (node.children) {
            const found = findNode(node.children, key);
            if (found) return found;
          }
        }
        return null;
      };

      const selectedNode = findNode(outline, selectedKeys[0] as string);
      if (selectedNode) {
        onSelectNode(selectedNode);
      }
    }
  };

  if (loading) {
    return (
      <div style={{ textAlign: 'center', padding: '40px 0' }}>
        <Spin tip="åŠ è½½ç›®å½•ä¸­..." />
      </div>
    );
  }

  return (
    <div style={{ height: '100%', display: 'flex', flexDirection: 'column' }}>
      <div style={{ padding: '12px 16px', borderBottom: '1px solid #f0f0f0' }}>
        <Input
          placeholder="æœç´¢ç›®å½•..."
          prefix={<SearchOutlined />}
          value={searchValue}
          onChange={(e) => setSearchValue(e.target.value)}
          allowClear
        />
      </div>

      <div style={{ flex: 1, overflow: 'auto', padding: '8px 0' }}>
        {treeData.length > 0 ? (
          <Tree
            showIcon
            defaultExpandAll
            expandedKeys={expandedKeys}
            onExpand={(keys) => setExpandedKeys(keys as string[])}
            treeData={treeData}
            onSelect={handleSelect}
            style={{ background: 'transparent' }}
          />
        ) : (
          <div style={{ textAlign: 'center', padding: '40px 16px', color: '#999' }}>
            {searchValue ? 'æœªæ‰¾åˆ°åŒ¹é…çš„ç›®å½•é¡¹' : 'æš‚æ— ç›®å½•ç»“æ„'}
          </div>
        )}
      </div>
    </div>
  );
};

export default TemplateOutlineTree;
```

#### 2.2 æ”¹é€ TemplateEditorç»„ä»¶

**æ–‡ä»¶**: `apps/web/src/pages/TemplateEditor.tsx`

```typescript
import React, { useState, useRef } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { Layout, Card, Button, Space, Tag, Tooltip, message } from 'antd';
import {
  ArrowLeftOutlined,
  FileTextOutlined,
  DownloadOutlined,
  SaveOutlined,
  ExpandOutlined,
  CompressOutlined
} from '@ant-design/icons';
import DocxEditor from '../components/DocxEditor';
import TemplateOutlineTree from '../components/TemplateOutlineTree';

const { Sider, Content } = Layout;

const TemplateEditor: React.FC = () => {
  const { id } = useParams<{ id: string }>();
  const navigate = useNavigate();
  const [collapsed, setCollapsed] = useState(false);
  const editorRef = useRef<any>(null);

  if (!id) {
    return (
      <div style={{ padding: 24, textAlign: 'center' }}>
        <p>æ¨¡æ¿IDç¼ºå¤±</p>
      </div>
    );
  }

  // å¤„ç†ç›®å½•èŠ‚ç‚¹é€‰æ‹© - è·³è½¬åˆ°å¯¹åº”ç« èŠ‚
  const handleNodeSelect = (node: any) => {
    // TODO: å®ç°è·³è½¬åˆ°Wordæ–‡æ¡£å¯¹åº”ä½ç½®
    // OnlyOffice API: editor.jumpTo(bookmark)
    message.info(`è·³è½¬åˆ°: ${node.title}`);
  };

  // å¯¼å‡ºWordæ–‡æ¡£
  const handleExport = () => {
    // TODO: è°ƒç”¨OnlyOffice APIå¯¼å‡ºæ–‡æ¡£
    message.info('æ­£åœ¨å¯¼å‡º...');
  };

  // ä¿å­˜æ–‡æ¡£
  const handleSave = () => {
    // OnlyOfficeä¼šè‡ªåŠ¨ä¿å­˜
    message.success('æ–‡æ¡£å·²è‡ªåŠ¨ä¿å­˜');
  };

  return (
    <div style={{ height: '100vh', display: 'flex', flexDirection: 'column' }}>
      {/* é¡¶éƒ¨å·¥å…·æ  */}
      <Card
        style={{ borderRadius: 0, borderBottom: '1px solid #f0f0f0' }}
        bodyStyle={{ padding: '12px 24px' }}
      >
        <div style={{
          display: 'flex',
          justifyContent: 'space-between',
          alignItems: 'center'
        }}>
          <Space size="large">
            <Button
              icon={<ArrowLeftOutlined />}
              onClick={() => navigate('/templates')}
            >
              è¿”å›åˆ—è¡¨
            </Button>
            <div>
              <Space>
                <FileTextOutlined style={{ fontSize: 18, color: '#1890ff' }} />
                <span style={{ fontSize: 16, fontWeight: 500 }}>
                  Wordæ¨¡æ¿ç¼–è¾‘å™¨
                </span>
                <Tag color="green">è‡ªåŠ¨ä¿å­˜</Tag>
              </Space>
            </div>
          </Space>

          <Space>
            <Tooltip title={collapsed ? "æ˜¾ç¤ºç›®å½•" : "éšè—ç›®å½•"}>
              <Button
                icon={collapsed ? <ExpandOutlined /> : <CompressOutlined />}
                onClick={() => setCollapsed(!collapsed)}
              />
            </Tooltip>
            <Button icon={<SaveOutlined />} onClick={handleSave}>
              ä¿å­˜
            </Button>
            <Button
              type="primary"
              icon={<DownloadOutlined />}
              onClick={handleExport}
            >
              å¯¼å‡º
            </Button>
          </Space>
        </div>
      </Card>

      {/* ä¸»ä½“åŒºåŸŸ - å·¦å³åˆ†æ  */}
      <Layout style={{ flex: 1, background: '#f0f2f5' }}>
        {/* å·¦ä¾§ç›®å½•æ ‘ */}
        <Sider
          width={320}
          collapsed={collapsed}
          collapsedWidth={0}
          trigger={null}
          style={{
            background: '#fff',
            borderRight: '1px solid #f0f0f0',
            overflow: 'hidden'
          }}
        >
          <div style={{
            height: '100%',
            display: 'flex',
            flexDirection: 'column'
          }}>
            <div style={{
              padding: '16px',
              borderBottom: '1px solid #f0f0f0',
              background: '#fafafa',
              fontWeight: 500
            }}>
              æ–‡æ¡£ç›®å½•
            </div>
            <div style={{ flex: 1, overflow: 'auto' }}>
              <TemplateOutlineTree
                templateId={id}
                onSelectNode={handleNodeSelect}
              />
            </div>
          </div>
        </Sider>

        {/* å³ä¾§ç¼–è¾‘å™¨ */}
        <Content style={{ padding: 16, overflow: 'hidden' }}>
          <div style={{
            height: '100%',
            background: '#fff',
            borderRadius: 4,
            boxShadow: '0 2px 8px rgba(0,0,0,0.1)',
            overflow: 'hidden'
          }}>
            <DocxEditor
              ref={editorRef}
              documentId={id}
              height="100%"
            />
          </div>
        </Content>
      </Layout>
    </div>
  );
};

export default TemplateEditor;
```

---

### é˜¶æ®µ3ï¼šOnlyOfficeé›†æˆ â­â­â­

#### 3.1 å®ç°ç« èŠ‚è·³è½¬

éœ€è¦åœ¨DocxEditorç»„ä»¶ä¸­æš´éœ²è·³è½¬æ–¹æ³•ï¼š

**æ–‡ä»¶**: `apps/web/src/components/DocxEditor.tsx`

```typescript
// åœ¨DocxEditorç»„ä»¶ä¸­æ·»åŠ æ–¹æ³•

useImperativeHandle(ref, () => ({
  // è·³è½¬åˆ°æŒ‡å®šä¹¦ç­¾/æ ‡é¢˜
  jumpToHeading: (headingText: string) => {
    if (editorInstance) {
      // OnlyOffice API: æœç´¢å¹¶è·³è½¬
      editorInstance.asc_findText(headingText, true, false);
    }
  },

  // å¯¼å‡ºæ–‡æ¡£
  downloadDocument: () => {
    if (editorInstance) {
      editorInstance.downloadAs('docx', 'template.docx');
    }
  }
}));
```

#### 3.2 æ›´æ–°TemplateEditorä½¿ç”¨ref

```typescript
const handleNodeSelect = (node: any) => {
  if (editorRef.current) {
    editorRef.current.jumpToHeading(node.title);
  }
};

const handleExport = () => {
  if (editorRef.current) {
    editorRef.current.downloadDocument();
  }
};
```

---

## ğŸ“ APIæ¥å£æ¸…å•

### 1. è·å–æ¨¡æ¿ç›®å½•ç»“æ„
```
GET /api/unified-document/templates/:id/outline

Response:
{
  "success": true,
  "data": {
    "outline": [
      {
        "id": "heading_0",
        "title": "1. æ€»åˆ™",
        "level": 1,
        "order": 0,
        "children": [
          {
            "id": "heading_1",
            "title": "1.1 é€‚ç”¨èŒƒå›´",
            "level": 2,
            "order": 1,
            "children": []
          }
        ]
      }
    ],
    "flatOutline": [...]
  }
}
```

---

## ğŸ§ª æµ‹è¯•è®¡åˆ’

### å•å…ƒæµ‹è¯•
1. `WordOutlineExtractor.test.js` - æµ‹è¯•Wordè§£æåŠŸèƒ½
2. `TemplateOutlineTree.test.tsx` - æµ‹è¯•ç›®å½•æ ‘ç»„ä»¶

### é›†æˆæµ‹è¯•
1. ä¸Šä¼ åŒ…å«å¤šçº§æ ‡é¢˜çš„Wordæ–‡æ¡£
2. éªŒè¯ç›®å½•æå–æ­£ç¡®æ€§
3. æµ‹è¯•ç›®å½•ç‚¹å‡»è·³è½¬
4. æµ‹è¯•ç¼–è¾‘å’Œä¿å­˜åŠŸèƒ½
5. æµ‹è¯•å¯¼å‡ºåŠŸèƒ½

### æµ‹è¯•ç”¨ä¾‹
```
æµ‹è¯•æ–‡æ¡£ç»“æ„ï¼š
1. æ€»åˆ™
  1.1 ç¼–åˆ¶ä¾æ®
  1.2 é€‚ç”¨èŒƒå›´
2. æœ¯è¯­å’Œå®šä¹‰
  2.1 åŸºæœ¬æœ¯è¯­
  2.2 ä¸“ä¸šæœ¯è¯­
3. æŠ€æœ¯è¦æ±‚
  3.1 ææ–™è¦æ±‚
  3.2 æ–½å·¥è¦æ±‚
    3.2.1 å‡†å¤‡å·¥ä½œ
    3.2.2 æ–½å·¥æµç¨‹
4. è´¨é‡æ ‡å‡†
```

---

## ğŸ“¦ ä¾èµ–åŒ…

### åç«¯
```json
{
  "mammoth": "^1.7.2",
  "docx": "^8.5.0"
}
```

### å‰ç«¯
æ— éœ€æ–°å¢ä¾èµ–ï¼ˆä½¿ç”¨Antdç°æœ‰ç»„ä»¶ï¼‰

---

## ğŸš€ éƒ¨ç½²æ­¥éª¤

1. **å®‰è£…åç«¯ä¾èµ–**
```bash
cd apps/api
npm install mammoth docx
```

2. **é‡å¯åç«¯æœåŠ¡**
```bash
npm run dev
```

3. **å‰ç«¯æ— éœ€é¢å¤–æ“ä½œ**ï¼ˆå·²æœ‰ä¾èµ–è¶³å¤Ÿï¼‰

4. **æµ‹è¯•æ–°åŠŸèƒ½**
   - ä¸Šä¼ ä¸€ä¸ªåŒ…å«æ ‡é¢˜çš„Wordæ–‡æ¡£
   - è¿›å…¥æ¨¡æ¿ç¼–è¾‘é¡µé¢
   - éªŒè¯å·¦ä¾§æ˜¾ç¤ºç›®å½•æ ‘
   - ç‚¹å‡»ç›®å½•é¡¹æµ‹è¯•è·³è½¬

---

## ğŸ¯ é¢„æœŸæ•ˆæœ

### ç”¨æˆ·ä½“éªŒ
1. **ç›´è§‚çš„ç›®å½•å¯¼èˆª** - ç±»ä¼¼Wordçš„å¯¼èˆªçª—æ ¼
2. **å¿«é€Ÿå®šä½ç« èŠ‚** - ç‚¹å‡»å³å¯è·³è½¬
3. **ä¿æŒåŸæ ¼å¼** - OnlyOfficeå®Œç¾ä¿ç•™Wordæ ¼å¼
4. **è‡ªåŠ¨ä¿å­˜** - ç¼–è¾‘å®æ—¶åŒæ­¥
5. **ä¾¿æ·å¯¼å‡º** - ä¸€é”®å¯¼å‡ºä¸ºWord

### æŠ€æœ¯ä¼˜åŠ¿
1. **å‡†ç¡®çš„ç›®å½•æå–** - åŸºäºWordæ ‡é¢˜æ ·å¼
2. **å±‚çº§ç»“æ„æ¸…æ™°** - æ ‘å½¢å±•ç¤º
3. **æœç´¢åŠŸèƒ½** - å¿«é€ŸæŸ¥æ‰¾ç›®å½•é¡¹
4. **å“åº”å¼å¸ƒå±€** - å¯æŠ˜å ä¾§è¾¹æ 

---

## ğŸ’¡ åç»­ä¼˜åŒ–

1. **ä¹¦ç­¾åŠŸèƒ½** - ç”¨æˆ·è‡ªå®šä¹‰ä¹¦ç­¾
2. **å†å²ç‰ˆæœ¬** - æŸ¥çœ‹å’Œæ¢å¤å†å²ç‰ˆæœ¬
3. **ååŒç¼–è¾‘** - å¤šäººåŒæ—¶ç¼–è¾‘
4. **æ‰¹æ³¨åŠŸèƒ½** - æ·»åŠ è¯„è®ºå’Œæ‰¹æ³¨
5. **æ¨¡æ¿å˜é‡é«˜äº®** - æ ‡è®°å¯æ›¿æ¢å˜é‡

---

## âš ï¸ æ³¨æ„äº‹é¡¹

1. **Wordæ ¼å¼å…¼å®¹æ€§** - ç¡®ä¿æ”¯æŒæ ‡é¢˜æ ·å¼è¯†åˆ«
2. **å¤§æ–‡ä»¶å¤„ç†** - ä¼˜åŒ–å¤§å‹æ–‡æ¡£çš„åŠ è½½é€Ÿåº¦
3. **OnlyOfficeé…ç½®** - éœ€è¦æ­£ç¡®é…ç½®OnlyOfficeæœåŠ¡å™¨
4. **æƒé™æ§åˆ¶** - ç¡®ä¿åªæœ‰æˆæƒç”¨æˆ·å¯ä»¥ç¼–è¾‘

---

## ğŸ“ é—®é¢˜æ’æŸ¥

### é—®é¢˜1ï¼šç›®å½•æ— æ³•æ˜¾ç¤º
- æ£€æŸ¥Wordæ–‡æ¡£æ˜¯å¦ä½¿ç”¨äº†æ ‡å‡†æ ‡é¢˜æ ·å¼
- æŸ¥çœ‹åç«¯æ—¥å¿—ç¡®è®¤è§£ææ˜¯å¦æˆåŠŸ
- éªŒè¯APIè¿”å›æ•°æ®æ ¼å¼

### é—®é¢˜2ï¼šè·³è½¬ä¸å·¥ä½œ
- ç¡®è®¤OnlyOffice APIç‰ˆæœ¬å…¼å®¹
- æ£€æŸ¥æ ‡é¢˜æ–‡æœ¬åŒ¹é…æ˜¯å¦å‡†ç¡®
- æŸ¥çœ‹æµè§ˆå™¨æ§åˆ¶å°é”™è¯¯ä¿¡æ¯

### é—®é¢˜3ï¼šå¯¼å‡ºå¤±è´¥
- éªŒè¯OnlyOfficeæœåŠ¡å™¨é…ç½®
- æ£€æŸ¥ç½‘ç»œè¿æ¥çŠ¶æ€
- æŸ¥çœ‹æœåŠ¡å™¨ç«¯é”™è¯¯æ—¥å¿—
