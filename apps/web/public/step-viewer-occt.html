<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>å·¥ä¸šçº§STEPæŸ¥çœ‹å™¨ - OpenCascade Technology</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: #1e1e1e;
      color: #e0e0e0;
      overflow: hidden;
    }

    #container { display: flex; height: 100vh; }

    /* ä¾§è¾¹æ  */
    #sidebar {
      width: 320px;
      background: #252526;
      border-right: 1px solid #3e3e42;
      display: flex;
      flex-direction: column;
    }

    #sidebar-header {
      padding: 16px;
      background: #2d2d30;
      border-bottom: 1px solid #3e3e42;
    }

    #sidebar-header h2 {
      font-size: 14px;
      font-weight: 600;
      color: #cccccc;
      margin-bottom: 12px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .btn-group { display: flex; gap: 8px; margin-bottom: 8px; }

    .btn {
      flex: 1;
      padding: 8px 12px;
      background: #0e639c;
      border: none;
      border-radius: 4px;
      color: white;
      font-size: 12px;
      cursor: pointer;
      transition: all 0.2s;
      font-weight: 500;
    }

    .btn:hover { background: #1177bb; transform: translateY(-1px); }
    .btn:active { background: #0d5a8f; transform: translateY(0); }
    .btn-secondary { background: #3e3e42; }
    .btn-secondary:hover { background: #505050; }
    .btn:disabled {
      background: #2d2d30;
      color: #666;
      cursor: not-allowed;
      transform: none;
    }

    #assembly-tree {
      flex: 1;
      overflow-y: auto;
      padding: 8px;
    }

    .tree-item {
      padding: 8px 12px;
      cursor: pointer;
      border-radius: 4px;
      margin-bottom: 2px;
      display: flex;
      align-items: center;
      font-size: 13px;
      transition: all 0.15s;
    }

    .tree-item:hover { background: #2a2d2e; }
    .tree-item.selected {
      background: #094771;
      color: white;
      box-shadow: 0 2px 8px rgba(9,71,113,0.3);
    }

    .tree-item-icon { margin-right: 8px; width: 16px; text-align: center; }
    .tree-item-color {
      width: 12px;
      height: 12px;
      border-radius: 2px;
      margin-right: 8px;
      border: 1px solid #555;
    }

    /* ä¸»è§†å£ */
    #viewport { flex: 1; display: flex; flex-direction: column; }

    #toolbar {
      height: 48px;
      background: #2d2d30;
      border-bottom: 1px solid #3e3e42;
      display: flex;
      align-items: center;
      padding: 0 16px;
      gap: 8px;
    }

    .toolbar-separator {
      width: 1px;
      height: 24px;
      background: #3e3e42;
      margin: 0 8px;
    }

    .tool-btn {
      width: 36px;
      height: 36px;
      background: transparent;
      border: 1px solid transparent;
      border-radius: 4px;
      color: #cccccc;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      transition: all 0.15s;
    }

    .tool-btn:hover {
      background: #3e3e42;
      border-color: #505050;
    }

    .tool-btn.active {
      background: #094771;
      border-color: #1177bb;
      color: white;
    }

    #canvas-container {
      flex: 1;
      position: relative;
      background: linear-gradient(180deg, #1e1e1e 0%, #252526 100%);
    }

    #render-canvas {
      width: 100%;
      height: 100%;
      display: block;
    }

    /* çŠ¶æ€æ  */
    #statusbar {
      height: 28px;
      background: #007acc;
      color: white;
      display: flex;
      align-items: center;
      padding: 0 12px;
      font-size: 12px;
      gap: 16px;
    }

    .status-item { display: flex; align-items: center; gap: 6px; }

    /* åŠ è½½é¢æ¿ */
    #loading-panel {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #2d2d30;
      padding: 32px 48px;
      border-radius: 8px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.6);
      text-align: center;
      z-index: 1000;
      min-width: 320px;
    }

    .spinner {
      width: 48px;
      height: 48px;
      border: 4px solid #3e3e42;
      border-top-color: #007acc;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 0 auto 16px;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    #loading-text {
      font-size: 14px;
      color: #cccccc;
      margin-bottom: 8px;
      font-weight: 500;
    }

    #loading-progress {
      font-size: 12px;
      color: #858585;
    }

    .progress-bar {
      width: 100%;
      height: 4px;
      background: #3e3e42;
      border-radius: 2px;
      overflow: hidden;
      margin-top: 12px;
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #007acc, #1177bb);
      width: 0%;
      transition: width 0.3s ease;
    }

    /* å±æ€§é¢æ¿ */
    #properties {
      padding: 16px;
      background: #1e1e1e;
      border-top: 1px solid #3e3e42;
      max-height: 250px;
      overflow-y: auto;
      display: none;
    }

    .property-row {
      display: flex;
      padding: 6px 0;
      border-bottom: 1px solid #2d2d30;
      font-size: 12px;
    }

    .property-label {
      width: 120px;
      color: #858585;
      font-weight: 500;
    }

    .property-value {
      flex: 1;
      color: #cccccc;
      font-family: 'Consolas', 'Monaco', monospace;
    }

    /* æ»šåŠ¨æ¡ */
    ::-webkit-scrollbar { width: 10px; height: 10px; }
    ::-webkit-scrollbar-track { background: #1e1e1e; }
    ::-webkit-scrollbar-thumb {
      background: #424242;
      border-radius: 5px;
    }
    ::-webkit-scrollbar-thumb:hover { background: #4e4e4e; }

    .badge {
      display: inline-block;
      padding: 2px 8px;
      background: #007acc;
      border-radius: 12px;
      font-size: 11px;
      font-weight: 600;
      color: white;
    }

    .badge-success { background: #4CAF50; }
    .badge-warning { background: #ff9800; }
    .badge-error { background: #f44336; }
  </style>
</head>
<body>
  <div id="container">
    <!-- ä¾§è¾¹æ  -->
    <div id="sidebar">
      <div id="sidebar-header">
        <h2>
          ğŸ—ï¸ STEPè£…é…æµè§ˆå™¨
          <span class="badge">OCCT</span>
        </h2>
        <div class="btn-group">
          <button class="btn" id="btn-load" onclick="loadAssemblySTEP()">ğŸ“‚ åŠ è½½STEP</button>
          <button class="btn btn-secondary" onclick="fitView()">ğŸ” é€‚é…</button>
        </div>
        <div class="btn-group">
          <button class="btn btn-secondary" onclick="toggleWireframe()">ğŸ“ çº¿æ¡†</button>
          <button class="btn btn-secondary" onclick="toggleGrid()">â¬œ ç½‘æ ¼</button>
        </div>
      </div>
      <div id="assembly-tree">
        <div class="tree-item">
          <span class="tree-item-icon">â³</span>
          <span>ç­‰å¾…åŠ è½½STEPæ–‡ä»¶...</span>
        </div>
      </div>
      <div id="properties">
        <h3 style="font-size: 13px; margin-bottom: 12px; color: #cccccc; font-weight: 600;">é›¶ä»¶å±æ€§</h3>
        <div id="property-list"></div>
      </div>
    </div>

    <!-- ä¸»è§†å£ -->
    <div id="viewport">
      <div id="toolbar">
        <div class="tool-btn active" title="é€‰æ‹©" onclick="setTool('select')">ğŸ–±ï¸</div>
        <div class="tool-btn" title="æµ‹é‡" onclick="setTool('measure')">ğŸ“</div>
        <div class="tool-btn" title="å‰–åˆ‡" onclick="setTool('section')">âœ‚ï¸</div>
        <div class="toolbar-separator"></div>
        <div class="tool-btn" title="å‰è§†å›¾" onclick="setView('front')">â¬œ</div>
        <div class="tool-btn" title="é¡¶è§†å›¾" onclick="setView('top')">â¬›</div>
        <div class="tool-btn" title="å³è§†å›¾" onclick="setView('right')">â¬›</div>
        <div class="tool-btn" title="ç­‰è½´æµ‹" onclick="setView('iso')">ğŸ“¦</div>
        <div class="toolbar-separator"></div>
        <div class="tool-btn" title="æˆªå›¾" onclick="takeScreenshot()">ğŸ“·</div>
        <div class="tool-btn" title="å¯¼å‡º" onclick="exportModel()">ğŸ’¾</div>
      </div>

      <div id="canvas-container">
        <canvas id="render-canvas"></canvas>
        <div id="loading-panel">
          <div class="spinner"></div>
          <div id="loading-text">æ­£åœ¨åˆå§‹åŒ–OCCTå¼•æ“...</div>
          <div id="loading-progress">å‡†å¤‡åŠ è½½ OpenCascade WebAssembly</div>
          <div class="progress-bar">
            <div class="progress-fill" id="progress-fill"></div>
          </div>
        </div>
      </div>

      <div id="statusbar">
        <div class="status-item">
          <span>ğŸ“¦</span>
          <span id="part-count">0 ä¸ªé›¶ä»¶</span>
        </div>
        <div class="status-item">
          <span>ğŸ“</span>
          <span id="face-count">0 é¢</span>
        </div>
        <div class="status-item">
          <span>ğŸ¨</span>
          <span id="render-mode">ç€è‰²</span>
        </div>
        <div class="status-item">
          <span>ğŸ“Š</span>
          <span id="fps-counter">-- FPS</span>
        </div>
        <div class="status-item" style="margin-left: auto;">
          <span id="status-text">åˆå§‹åŒ–ä¸­...</span>
        </div>
      </div>
    </div>
  </div>

  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
    }
  }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { TransformControls } from 'three/addons/controls/TransformControls.js';

    // å…¨å±€çŠ¶æ€
    let scene, camera, renderer, controls, transformControls;
    let parts = [];
    let selectedPart = null;
    let gridHelper = null;
    let occt = null;
    let wireframeMode = false;

    // åˆå§‹åŒ–Three.js
    function initScene() {
      const canvas = document.getElementById('render-canvas');
      const container = document.getElementById('canvas-container');

      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x2a2a2a);

      camera = new THREE.PerspectiveCamera(
        45,
        container.clientWidth / container.clientHeight,
        0.1,
        100000
      );
      camera.position.set(1500, 1200, 1500);

      renderer = new THREE.WebGLRenderer({
        canvas,
        antialias: true,
        alpha: false
      });
      renderer.setSize(container.clientWidth, container.clientHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.0;

      controls = new OrbitControls(camera, canvas);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.minDistance = 10;
      controls.maxDistance = 50000;

      transformControls = new TransformControls(camera, canvas);
      transformControls.addEventListener('dragging-changed', (e) => {
        controls.enabled = !e.value;
      });
      scene.add(transformControls);

      // å·¥ä¸šçº§ç…§æ˜è®¾ç½®
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
      scene.add(ambientLight);

      const keyLight = new THREE.DirectionalLight(0xffffff, 0.8);
      keyLight.position.set(3000, 3000, 2000);
      keyLight.castShadow = true;
      keyLight.shadow.camera.left = -3000;
      keyLight.shadow.camera.right = 3000;
      keyLight.shadow.camera.top = 3000;
      keyLight.shadow.camera.bottom = -3000;
      keyLight.shadow.mapSize.width = 4096;
      keyLight.shadow.mapSize.height = 4096;
      scene.add(keyLight);

      const fillLight = new THREE.DirectionalLight(0xb0c4de, 0.3);
      fillLight.position.set(-2000, 1500, -1000);
      scene.add(fillLight);

      const rimLight = new THREE.DirectionalLight(0xffffff, 0.2);
      rimLight.position.set(0, 1000, -2000);
      scene.add(rimLight);

      // ç½‘æ ¼
      gridHelper = new THREE.GridHelper(5000, 100, 0x444444, 0x2a2a2a);
      scene.add(gridHelper);

      // åæ ‡è½´
      const axesHelper = new THREE.AxesHelper(800);
      scene.add(axesHelper);

      window.addEventListener('resize', onWindowResize);
      canvas.addEventListener('click', onCanvasClick);

      animate();
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }

    function onWindowResize() {
      const container = document.getElementById('canvas-container');
      camera.aspect = container.clientWidth / container.clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(container.clientWidth, container.clientHeight);
    }

    // åˆå§‹åŒ–OCCT (ä½¿ç”¨occt-import-js)
    async function initOCCT() {
      try {
        updateProgress(10, 'åŠ è½½OCCTåº“...');

        // åŠ¨æ€åŠ è½½ occt-import-js
        const script = document.createElement('script');
        script.src = 'https://cdn.jsdelivr.net/npm/occt-import-js@0.0.12/dist/occt-import-js.js';

        await new Promise((resolve, reject) => {
          script.onload = resolve;
          script.onerror = () => reject(new Error('OCCTåº“åŠ è½½å¤±è´¥'));
          document.head.appendChild(script);
        });

        updateProgress(50, 'åˆå§‹åŒ–OCCTå¼•æ“...');

        // åˆå§‹åŒ– occt-import-js
        if (typeof occtimportjs === 'undefined') {
          throw new Error('occt-import-js æœªæ­£ç¡®åŠ è½½');
        }

        occt = await occtimportjs();

        updateProgress(100, 'OCCTå¼•æ“å°±ç»ª');
        updateStatus('âœ… OpenCascadeå¼•æ“å·²å°±ç»ª');

        setTimeout(() => {
          document.getElementById('loading-panel').style.display = 'none';
        }, 500);

        return true;
      } catch (error) {
        console.error('OCCTåˆå§‹åŒ–å¤±è´¥:', error);
        updateStatus('âŒ OCCTå¼•æ“åˆå§‹åŒ–å¤±è´¥');
        document.getElementById('loading-text').textContent = 'åˆå§‹åŒ–å¤±è´¥';
        document.getElementById('loading-progress').textContent = error.message;
        return false;
      }
    }

    // åŠ è½½STEPè£…é…
    window.loadAssemblySTEP = async function() {
      if (!occt) {
        alert('OCCTå¼•æ“å°šæœªåˆå§‹åŒ–');
        return;
      }

      document.getElementById('loading-panel').style.display = 'block';
      document.getElementById('loading-text').textContent = 'åŠ è½½STEPè£…é…...';
      updateProgress(0, 'å‡†å¤‡åŠ è½½...');

      try {
        // ä½¿ç”¨ç°æœ‰çš„assembly.jsonä½œä¸ºéª¨æ¶ï¼ŒåŠ è½½çœŸå®STEPæ–‡ä»¶
        updateProgress(10, 'åŠ è½½è£…é…æ¸…å•...');
        const response = await fetch('./assembly.json');
        const data = await response.json();

        // æ¸…ç©ºåœºæ™¯
        parts.forEach(p => scene.remove(p.mesh));
        parts = [];

        const children = data.object.children;
        const treeHtml = [];

        for (let i = 0; i < children.length; i++) {
          const child = children[i];
          const partName = child.name.split('_')[0];
          const position = new THREE.Vector3(
            child.matrix[12],
            child.matrix[13],
            child.matrix[14]
          );

          updateProgress(
            10 + (i / children.length) * 80,
            `åŠ è½½é›¶ä»¶ ${i+1}/${children.length}: ${partName}`
          );

          try {
            // å°è¯•åŠ è½½STEPæ–‡ä»¶
            const stepUrl = `/step/${partName}.STEP`;
            const stepData = await loadStepFile(stepUrl, partName);

            if (stepData) {
              // ä½¿ç”¨OCCTè§£æçš„å‡ ä½•ä½“
              parts.push(stepData);
              scene.add(stepData.mesh);
            } else {
              // é™çº§åˆ°STL
              const geometry = await loadSTLFallback(partName);
              const material = new THREE.MeshStandardMaterial({
                color: 0xcad1ee,
                metalness: 0.3,
                roughness: 0.6
              });
              const mesh = new THREE.Mesh(geometry, material);
              mesh.position.copy(position);
              mesh.userData = { partId: partName, index: i };
              parts.push({ name: child.name, mesh, color: '#cad1ee' });
              scene.add(mesh);
            }

            treeHtml.push(`
              <div class="tree-item" data-index="${i}" onclick="selectPart(${i})">
                <span class="tree-item-icon">ğŸ”©</span>
                <div class="tree-item-color" style="background: #cad1ee"></div>
                <span>${child.name}</span>
              </div>
            `);
          } catch (error) {
            console.warn(`åŠ è½½å¤±è´¥ ${partName}:`, error);
          }
        }

        document.getElementById('assembly-tree').innerHTML = treeHtml.join('');
        document.getElementById('part-count').textContent = `${parts.length} ä¸ªé›¶ä»¶`;

        fitView();

        updateProgress(100, 'åŠ è½½å®Œæˆ');
        document.getElementById('loading-panel').style.display = 'none';
        updateStatus(`âœ… è£…é…åŠ è½½å®Œæˆ: ${parts.length} ä¸ªé›¶ä»¶`);
      } catch (error) {
        console.error('è£…é…åŠ è½½å¤±è´¥:', error);
        updateStatus('âŒ è£…é…åŠ è½½å¤±è´¥');
        document.getElementById('loading-text').textContent = 'åŠ è½½å¤±è´¥';
        document.getElementById('loading-progress').textContent = error.message;
      }
    }

    // ä½¿ç”¨OCCTåŠ è½½STEPæ–‡ä»¶
    async function loadStepFile(url, partName) {
      try {
        const response = await fetch(url);
        if (!response.ok) throw new Error('æ–‡ä»¶ä¸å­˜åœ¨');

        const arrayBuffer = await response.arrayBuffer();
        const fileData = new Uint8Array(arrayBuffer);

        // ä½¿ç”¨ occt-import-js è¯»å–STEP
        const result = await occt.ReadStepFile(fileData, null);

        if (!result || !result.success) {
          console.warn(`STEPè§£æå¤±è´¥: ${partName}`);
          return null;
        }

        // è½¬æ¢ä¸ºThree.jså‡ ä½•ä½“
        if (result.meshes && result.meshes.length > 0) {
          const mesh = result.meshes[0];

          const geometry = new THREE.BufferGeometry();
          geometry.setAttribute('position', new THREE.Float32BufferAttribute(mesh.attributes.position.array, 3));
          geometry.setAttribute('normal', new THREE.Float32BufferAttribute(mesh.attributes.normal.array, 3));

          if (mesh.index) {
            geometry.setIndex(new THREE.BufferAttribute(mesh.index.array, 1));
          }

          geometry.computeVertexNormals();

          // æå–é¢œè‰²
          const color = mesh.color || [0.8, 0.8, 0.9];
          const material = new THREE.MeshStandardMaterial({
            color: new THREE.Color(color[0], color[1], color[2]),
            metalness: 0.3,
            roughness: 0.6
          });

          const threeMesh = new THREE.Mesh(geometry, material);
          threeMesh.userData = { partId: partName, fromSTEP: true };

          return {
            name: partName,
            mesh: threeMesh,
            color: `#${Math.round(color[0]*255).toString(16).padStart(2,'0')}${Math.round(color[1]*255).toString(16).padStart(2,'0')}${Math.round(color[2]*255).toString(16).padStart(2,'0')}`
          };
        }

        return null;
      } catch (error) {
        console.warn(`STEPåŠ è½½å¤±è´¥ ${partName}:`, error);
        return null;
      }
    }

    // STLé™çº§æ–¹æ¡ˆ
    async function loadSTLFallback(partName) {
      const { STLLoader } = await import('three/addons/loaders/STLLoader.js');
      const loader = new STLLoader();

      return new Promise((resolve, reject) => {
        loader.load(
          `/stl/${partName}.stl`,
          (geometry) => {
            geometry.computeVertexNormals();
            resolve(geometry);
          },
          undefined,
          reject
        );
      });
    }

    // é€‰æ‹©é›¶ä»¶
    window.selectPart = function(index) {
      if (selectedPart !== null && parts[selectedPart]) {
        parts[selectedPart].mesh.material.emissive.setHex(0x000000);
        document.querySelectorAll('.tree-item').forEach(el => {
          el.classList.remove('selected');
        });
      }

      selectedPart = index;
      const part = parts[index];

      if (part) {
        part.mesh.material.emissive.setHex(0x555555);
        document.querySelector(`.tree-item[data-index="${index}"]`)?.classList.add('selected');
        showProperties(part);
        transformControls.attach(part.mesh);
        updateStatus(`å·²é€‰æ‹©: ${part.name}`);
      }
    }

    function onCanvasClick(event) {
      const canvas = document.getElementById('render-canvas');
      const rect = canvas.getBoundingClientRect();
      const mouse = new THREE.Vector2(
        ((event.clientX - rect.left) / rect.width) * 2 - 1,
        -((event.clientY - rect.top) / rect.height) * 2 + 1
      );

      const raycaster = new THREE.Raycaster();
      raycaster.setFromCamera(mouse, camera);

      const meshes = parts.map(p => p.mesh);
      const intersects = raycaster.intersectObjects(meshes, false);

      if (intersects.length > 0) {
        const index = intersects[0].object.userData.index;
        selectPart(index);
      }
    }

    function showProperties(part) {
      const props = document.getElementById('properties');
      props.style.display = 'block';

      const pos = part.mesh.position;
      const rot = part.mesh.rotation;

      document.getElementById('property-list').innerHTML = `
        <div class="property-row">
          <div class="property-label">é›¶ä»¶åç§°</div>
          <div class="property-value">${part.name}</div>
        </div>
        <div class="property-row">
          <div class="property-label">ä½ç½® (X,Y,Z)</div>
          <div class="property-value">${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)} mm</div>
        </div>
        <div class="property-row">
          <div class="property-label">æ—‹è½¬ (X,Y,Z)</div>
          <div class="property-value">${(rot.x*180/Math.PI).toFixed(1)}Â°, ${(rot.y*180/Math.PI).toFixed(1)}Â°, ${(rot.z*180/Math.PI).toFixed(1)}Â°</div>
        </div>
        <div class="property-row">
          <div class="property-label">é¢œè‰²</div>
          <div class="property-value">${part.color}</div>
        </div>
      `;
    }

    // å·¥å…·å‡½æ•°
    window.setTool = function(tool) {
      updateStatus(`å·¥å…·: ${tool}`);
    }

    window.setView = function(view) {
      const dist = 1800;
      const views = {
        front: [0, 0, dist],
        top: [0, dist, 0],
        right: [dist, 0, 0],
        iso: [dist, dist*0.8, dist]
      };
      camera.position.set(...views[view]);
      camera.lookAt(0, 0, 0);
      controls.target.set(0, 0, 0);
      controls.update();
    }

    window.fitView = function() {
      if (parts.length === 0) return;

      const box = new THREE.Box3();
      parts.forEach(p => box.expandByObject(p.mesh));

      const center = new THREE.Vector3();
      box.getCenter(center);

      const size = new THREE.Vector3();
      box.getSize(size);

      const maxDim = Math.max(size.x, size.y, size.z);
      const dist = maxDim * 1.8;

      camera.position.set(center.x + dist, center.y + dist*0.7, center.z + dist);
      camera.lookAt(center);
      controls.target.copy(center);
      controls.update();
    }

    window.toggleGrid = function() {
      gridHelper.visible = !gridHelper.visible;
    }

    window.toggleWireframe = function() {
      wireframeMode = !wireframeMode;
      parts.forEach(p => {
        p.mesh.material.wireframe = wireframeMode;
      });
      document.getElementById('render-mode').textContent = wireframeMode ? 'çº¿æ¡†' : 'ç€è‰²';
    }

    window.takeScreenshot = function() {
      renderer.render(scene, camera);
      const dataURL = renderer.domElement.toDataURL('image/png');
      const link = document.createElement('a');
      link.download = `assembly_${Date.now()}.png`;
      link.href = dataURL;
      link.click();
      updateStatus('âœ… æˆªå›¾å·²ä¿å­˜');
    }

    window.exportModel = function() {
      updateStatus('å¯¼å‡ºåŠŸèƒ½å¼€å‘ä¸­...');
    }

    function updateProgress(percent, message) {
      document.getElementById('progress-fill').style.width = `${percent}%`;
      document.getElementById('loading-progress').textContent = message;
    }

    function updateStatus(text) {
      document.getElementById('status-text').textContent = text;
    }

    // FPSè®¡æ•°
    let frames = 0, lastTime = performance.now();
    setInterval(() => {
      const now = performance.now();
      const fps = Math.round(frames * 1000 / (now - lastTime));
      document.getElementById('fps-counter').textContent = `${fps} FPS`;
      frames = 0;
      lastTime = now;
    }, 1000);

    function countFrame() {
      frames++;
      requestAnimationFrame(countFrame);
    }
    countFrame();

    // åˆå§‹åŒ–
    initScene();
    initOCCT();
  </script>
</body>
</html>
