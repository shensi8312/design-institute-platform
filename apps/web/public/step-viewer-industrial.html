<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>å·¥ä¸šçº§STEPè£…é…æŸ¥çœ‹å™¨ - OCCT.js</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: #1e1e1e;
      color: #e0e0e0;
      overflow: hidden;
    }

    #container {
      display: flex;
      height: 100vh;
    }

    /* ä¾§è¾¹æ  */
    #sidebar {
      width: 320px;
      background: #252526;
      border-right: 1px solid #3e3e42;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    #sidebar-header {
      padding: 16px;
      background: #2d2d30;
      border-bottom: 1px solid #3e3e42;
    }

    #sidebar-header h2 {
      font-size: 14px;
      font-weight: 600;
      color: #cccccc;
      margin-bottom: 12px;
    }

    .btn-group {
      display: flex;
      gap: 8px;
      margin-bottom: 8px;
    }

    .btn {
      flex: 1;
      padding: 8px 12px;
      background: #0e639c;
      border: none;
      border-radius: 4px;
      color: white;
      font-size: 12px;
      cursor: pointer;
      transition: background 0.2s;
    }

    .btn:hover { background: #1177bb; }
    .btn:active { background: #0d5a8f; }
    .btn-secondary { background: #3e3e42; }
    .btn-secondary:hover { background: #505050; }

    #assembly-tree {
      flex: 1;
      overflow-y: auto;
      padding: 8px;
    }

    .tree-item {
      padding: 8px 12px;
      cursor: pointer;
      border-radius: 4px;
      margin-bottom: 2px;
      display: flex;
      align-items: center;
      font-size: 13px;
      transition: background 0.15s;
    }

    .tree-item:hover {
      background: #2a2d2e;
    }

    .tree-item.selected {
      background: #094771;
      color: white;
    }

    .tree-item-icon {
      margin-right: 8px;
      width: 16px;
      text-align: center;
    }

    .tree-item-color {
      width: 12px;
      height: 12px;
      border-radius: 2px;
      margin-right: 8px;
      border: 1px solid #555;
    }

    /* ä¸»è§†å£ */
    #viewport {
      flex: 1;
      display: flex;
      flex-direction: column;
    }

    #toolbar {
      height: 48px;
      background: #2d2d30;
      border-bottom: 1px solid #3e3e42;
      display: flex;
      align-items: center;
      padding: 0 16px;
      gap: 8px;
    }

    .toolbar-separator {
      width: 1px;
      height: 24px;
      background: #3e3e42;
      margin: 0 8px;
    }

    .tool-btn {
      width: 36px;
      height: 36px;
      background: transparent;
      border: 1px solid transparent;
      border-radius: 4px;
      color: #cccccc;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      transition: all 0.15s;
    }

    .tool-btn:hover {
      background: #3e3e42;
      border-color: #505050;
    }

    .tool-btn.active {
      background: #094771;
      border-color: #1177bb;
      color: white;
    }

    #canvas-container {
      flex: 1;
      position: relative;
      background: #1e1e1e;
    }

    #render-canvas {
      width: 100%;
      height: 100%;
      display: block;
    }

    /* çŠ¶æ€æ  */
    #statusbar {
      height: 28px;
      background: #007acc;
      color: white;
      display: flex;
      align-items: center;
      padding: 0 12px;
      font-size: 12px;
      gap: 16px;
    }

    .status-item {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    /* åŠ è½½é¢æ¿ */
    #loading-panel {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #2d2d30;
      padding: 32px 48px;
      border-radius: 8px;
      box-shadow: 0 4px 24px rgba(0,0,0,0.5);
      text-align: center;
      z-index: 1000;
    }

    .spinner {
      width: 48px;
      height: 48px;
      border: 4px solid #3e3e42;
      border-top-color: #007acc;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 0 auto 16px;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    #loading-text {
      font-size: 14px;
      color: #cccccc;
      margin-bottom: 8px;
    }

    #loading-progress {
      font-size: 12px;
      color: #858585;
    }

    /* å±æ€§é¢æ¿ */
    #properties {
      padding: 16px;
      background: #1e1e1e;
      border-top: 1px solid #3e3e42;
      max-height: 200px;
      overflow-y: auto;
    }

    .property-row {
      display: flex;
      padding: 6px 0;
      border-bottom: 1px solid #2d2d30;
      font-size: 12px;
    }

    .property-label {
      width: 120px;
      color: #858585;
      font-weight: 500;
    }

    .property-value {
      flex: 1;
      color: #cccccc;
    }

    /* æ»šåŠ¨æ¡æ ·å¼ */
    ::-webkit-scrollbar {
      width: 10px;
      height: 10px;
    }

    ::-webkit-scrollbar-track {
      background: #1e1e1e;
    }

    ::-webkit-scrollbar-thumb {
      background: #424242;
      border-radius: 5px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: #4e4e4e;
    }
  </style>
</head>
<body>
  <div id="container">
    <!-- ä¾§è¾¹æ  -->
    <div id="sidebar">
      <div id="sidebar-header">
        <h2>ğŸ—ï¸ è£…é…ç»“æ„æ ‘</h2>
        <div class="btn-group">
          <button class="btn" onclick="loadAssembly()">ğŸ“‚ åŠ è½½è£…é…</button>
          <button class="btn btn-secondary" onclick="expandAll()">ğŸ“‹ å…¨éƒ¨å±•å¼€</button>
        </div>
        <div class="btn-group">
          <button class="btn btn-secondary" onclick="fitView()">ğŸ” é€‚é…è§†å›¾</button>
          <button class="btn btn-secondary" onclick="toggleGrid()">ğŸ“ ç½‘æ ¼</button>
        </div>
      </div>
      <div id="assembly-tree">
        <div class="tree-item">
          <span class="tree-item-icon">â³</span>
          <span>ç­‰å¾…åŠ è½½è£…é…...</span>
        </div>
      </div>
      <div id="properties" style="display: none;">
        <h3 style="font-size: 13px; margin-bottom: 12px; color: #cccccc;">é›¶ä»¶å±æ€§</h3>
        <div id="property-list"></div>
      </div>
    </div>

    <!-- ä¸»è§†å£ -->
    <div id="viewport">
      <div id="toolbar">
        <div class="tool-btn active" title="é€‰æ‹©" onclick="setTool('select')">ğŸ–±ï¸</div>
        <div class="tool-btn" title="æµ‹é‡è·ç¦»" onclick="setTool('measure')">ğŸ“</div>
        <div class="tool-btn" title="å‰–åˆ‡" onclick="setTool('section')">âœ‚ï¸</div>
        <div class="toolbar-separator"></div>
        <div class="tool-btn" title="çº¿æ¡†" onclick="setViewMode('wireframe')">ğŸ“</div>
        <div class="tool-btn" title="ç€è‰²" onclick="setViewMode('shaded')">ğŸ¨</div>
        <div class="tool-btn" title="ç€è‰²+è¾¹çº¿" onclick="setViewMode('shaded-edges')">ğŸ–¼ï¸</div>
        <div class="toolbar-separator"></div>
        <div class="tool-btn" title="å‰è§†å›¾" onclick="setView('front')">â¬œ</div>
        <div class="tool-btn" title="é¡¶è§†å›¾" onclick="setView('top')">â¬›</div>
        <div class="tool-btn" title="å³è§†å›¾" onclick="setView('right')">â¬›</div>
        <div class="tool-btn" title="ç­‰è½´æµ‹" onclick="setView('iso')">ğŸ“¦</div>
      </div>

      <div id="canvas-container">
        <canvas id="render-canvas"></canvas>
        <div id="loading-panel">
          <div class="spinner"></div>
          <div id="loading-text">æ­£åœ¨åˆå§‹åŒ–OCCTå¼•æ“...</div>
          <div id="loading-progress">åŠ è½½ OpenCascade WebAssembly</div>
        </div>
      </div>

      <div id="statusbar">
        <div class="status-item">
          <span>ğŸ“¦</span>
          <span id="part-count">0 ä¸ªé›¶ä»¶</span>
        </div>
        <div class="status-item">
          <span>ğŸ¨</span>
          <span id="render-mode">ç€è‰²+è¾¹çº¿</span>
        </div>
        <div class="status-item">
          <span>ğŸ“Š</span>
          <span id="fps-counter">60 FPS</span>
        </div>
        <div class="status-item" style="margin-left: auto;">
          <span id="status-text">å°±ç»ª</span>
        </div>
      </div>
    </div>
  </div>

  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
    }
  }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { TransformControls } from 'three/addons/controls/TransformControls.js';
    import { STLLoader } from 'three/addons/loaders/STLLoader.js';

    // å…¨å±€çŠ¶æ€
    let scene, camera, renderer, controls, transformControls;
    let parts = [];
    let selectedPart = null;
    let currentTool = 'select';
    let viewMode = 'shaded-edges';
    let gridHelper = null;

    // åˆå§‹åŒ–Three.jsåœºæ™¯
    function initScene() {
      const canvas = document.getElementById('render-canvas');
      const container = document.getElementById('canvas-container');

      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x1e1e1e);

      camera = new THREE.PerspectiveCamera(
        50,
        container.clientWidth / container.clientHeight,
        1,
        50000
      );
      camera.position.set(1000, 800, 1000);

      renderer = new THREE.WebGLRenderer({
        canvas,
        antialias: true,
        alpha: true
      });
      renderer.setSize(container.clientWidth, container.clientHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;

      controls = new OrbitControls(camera, canvas);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;

      transformControls = new TransformControls(camera, canvas);
      transformControls.addEventListener('dragging-changed', (event) => {
        controls.enabled = !event.value;
      });
      scene.add(transformControls);

      // ç¯å…‰ç³»ç»Ÿ
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambientLight);

      const keyLight = new THREE.DirectionalLight(0xffffff, 0.8);
      keyLight.position.set(2000, 2000, 2000);
      keyLight.castShadow = true;
      keyLight.shadow.camera.left = -2000;
      keyLight.shadow.camera.right = 2000;
      keyLight.shadow.camera.top = 2000;
      keyLight.shadow.camera.bottom = -2000;
      keyLight.shadow.mapSize.width = 2048;
      keyLight.shadow.mapSize.height = 2048;
      scene.add(keyLight);

      const fillLight = new THREE.DirectionalLight(0xffffff, 0.3);
      fillLight.position.set(-1000, 1000, -1000);
      scene.add(fillLight);

      const backLight = new THREE.DirectionalLight(0xffffff, 0.2);
      backLight.position.set(0, 500, -1500);
      scene.add(backLight);

      // ç½‘æ ¼
      gridHelper = new THREE.GridHelper(3000, 60, 0x444444, 0x2a2a2a);
      scene.add(gridHelper);

      // åæ ‡è½´
      const axesHelper = new THREE.AxesHelper(500);
      scene.add(axesHelper);

      // çª—å£è°ƒæ•´
      window.addEventListener('resize', onWindowResize);

      // é¼ æ ‡äº‹ä»¶
      canvas.addEventListener('click', onCanvasClick);

      animate();

      updateStatus('åœºæ™¯åˆå§‹åŒ–å®Œæˆ');
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }

    function onWindowResize() {
      const container = document.getElementById('canvas-container');
      camera.aspect = container.clientWidth / container.clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(container.clientWidth, container.clientHeight);
    }

    // åŠ è½½è£…é…ï¼ˆä½¿ç”¨Three.jsåŠ è½½å™¨æš‚æ—¶æ¨¡æ‹Ÿï¼Œåç»­æ›¿æ¢ä¸ºOCCT.jsï¼‰
    window.loadAssembly = async function() {
      updateStatus('æ­£åœ¨åŠ è½½è£…é…æ•°æ®...');
      document.getElementById('loading-panel').style.display = 'block';
      document.getElementById('loading-text').textContent = 'æ­£åœ¨åŠ è½½STEPæ–‡ä»¶...';

      try {
        // åŠ è½½è£…é…JSON
        const response = await fetch('./assembly.json');
        const data = await response.json();

        // æ¸…ç©ºç°æœ‰åœºæ™¯
        parts.forEach(part => scene.remove(part.mesh));
        parts = [];

        // åŠ è½½STEPé¢œè‰²æ˜ å°„
        let colorMap = {};
        try {
          const colorResponse = await fetch('/uploads/step_colors.json');
          colorMap = await colorResponse.json();
        } catch (e) {
          console.warn('é¢œè‰²æ˜ å°„åŠ è½½å¤±è´¥');
        }

        // åŠ è½½æ¯ä¸ªé›¶ä»¶ï¼ˆæš‚æ—¶ä½¿ç”¨å‡ ä½•ä½“æ¨¡æ‹Ÿï¼Œåç»­ç”¨OCCT.jsåŠ è½½çœŸå®STEPï¼‰
        const children = data.object.children;
        const treeHtml = [];
        const stlLoader = new STLLoader();

        document.getElementById('loading-progress').textContent = `åŠ è½½ä¸­: 0/${children.length}`;

        for (let i = 0; i < children.length; i++) {
          const child = children[i];
          const partName = child.name.split('_')[0];
          const position = new THREE.Vector3(
            child.matrix[12],
            child.matrix[13],
            child.matrix[14]
          );

          document.getElementById('loading-progress').textContent =
            `åŠ è½½é›¶ä»¶ ${i+1}/${children.length}: ${partName}`;

          try {
            // åŠ è½½çœŸå®çš„STLæ–‡ä»¶
            const geometry = await new Promise((resolve, reject) => {
              stlLoader.load(
                `/stl/${partName}.stl`,
                (geom) => {
                  geom.computeVertexNormals();
                  resolve(geom);
                },
                undefined,
                reject
              );
            });

            // ä½¿ç”¨çœŸå®é¢œè‰²
            const stepColor = colorMap[partName]?.hex || '#cad1ee';
            const material = new THREE.MeshStandardMaterial({
              color: parseInt(stepColor.replace('#', '0x')),
              metalness: 0.5,
              roughness: 0.5,
              side: THREE.DoubleSide
            });

            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.copy(position);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            mesh.userData = {
              partId: partName,
              index: i,
              originalColor: stepColor
            };

            scene.add(mesh);
            parts.push({ name: child.name, mesh, color: stepColor });

            // æ·»åŠ åˆ°æ ‘
            treeHtml.push(`
              <div class="tree-item" data-index="${i}" onclick="selectPart(${i})">
                <span class="tree-item-icon">ğŸ”©</span>
                <div class="tree-item-color" style="background: ${stepColor}"></div>
                <span>${child.name}</span>
              </div>
            `);
          } catch (error) {
            console.warn(`åŠ è½½å¤±è´¥ ${partName}:`, error);
          }
        }

        document.getElementById('assembly-tree').innerHTML = treeHtml.join('');
        document.getElementById('part-count').textContent = `${parts.length} ä¸ªé›¶ä»¶`;

        // é€‚é…è§†å›¾
        fitView();

        document.getElementById('loading-panel').style.display = 'none';
        updateStatus(`è£…é…åŠ è½½å®Œæˆ: ${parts.length} ä¸ªé›¶ä»¶`);
      } catch (error) {
        console.error('è£…é…åŠ è½½å¤±è´¥:', error);
        updateStatus('è£…é…åŠ è½½å¤±è´¥: ' + error.message);
        document.getElementById('loading-panel').style.display = 'none';
      }
    }

    // é€‰æ‹©é›¶ä»¶
    window.selectPart = function(index) {
      if (selectedPart !== null) {
        // å–æ¶ˆé«˜äº®
        parts[selectedPart].mesh.material.emissive.setHex(0x000000);
        document.querySelectorAll('.tree-item').forEach(el => {
          el.classList.remove('selected');
        });
      }

      selectedPart = index;
      const part = parts[index];

      // é«˜äº®é€‰ä¸­
      part.mesh.material.emissive.setHex(0x555555);
      document.querySelector(`.tree-item[data-index="${index}"]`).classList.add('selected');

      // æ˜¾ç¤ºå±æ€§
      showProperties(part);

      // é™„åŠ å˜æ¢æ§ä»¶
      if (currentTool === 'select') {
        transformControls.attach(part.mesh);
      }

      updateStatus(`å·²é€‰æ‹©: ${part.name}`);
    }

    function onCanvasClick(event) {
      if (currentTool !== 'select') return;

      const canvas = document.getElementById('render-canvas');
      const rect = canvas.getBoundingClientRect();
      const mouse = new THREE.Vector2(
        ((event.clientX - rect.left) / rect.width) * 2 - 1,
        -((event.clientY - rect.top) / rect.height) * 2 + 1
      );

      const raycaster = new THREE.Raycaster();
      raycaster.setFromCamera(mouse, camera);

      const meshes = parts.map(p => p.mesh);
      const intersects = raycaster.intersectObjects(meshes, false);

      if (intersects.length > 0) {
        const index = intersects[0].object.userData.index;
        selectPart(index);
      }
    }

    function showProperties(part) {
      const props = document.getElementById('properties');
      props.style.display = 'block';

      const position = part.mesh.position;
      const rotation = part.mesh.rotation;
      const scale = part.mesh.scale;

      document.getElementById('property-list').innerHTML = `
        <div class="property-row">
          <div class="property-label">é›¶ä»¶åç§°</div>
          <div class="property-value">${part.name}</div>
        </div>
        <div class="property-row">
          <div class="property-label">é¢œè‰²</div>
          <div class="property-value">${part.color}</div>
        </div>
        <div class="property-row">
          <div class="property-label">ä½ç½® X</div>
          <div class="property-value">${position.x.toFixed(2)} mm</div>
        </div>
        <div class="property-row">
          <div class="property-label">ä½ç½® Y</div>
          <div class="property-value">${position.y.toFixed(2)} mm</div>
        </div>
        <div class="property-row">
          <div class="property-label">ä½ç½® Z</div>
          <div class="property-value">${position.z.toFixed(2)} mm</div>
        </div>
        <div class="property-row">
          <div class="property-label">æ—‹è½¬ X</div>
          <div class="property-value">${(rotation.x * 180 / Math.PI).toFixed(2)}Â°</div>
        </div>
        <div class="property-row">
          <div class="property-label">æ—‹è½¬ Y</div>
          <div class="property-value">${(rotation.y * 180 / Math.PI).toFixed(2)}Â°</div>
        </div>
        <div class="property-row">
          <div class="property-label">æ—‹è½¬ Z</div>
          <div class="property-value">${(rotation.z * 180 / Math.PI).toFixed(2)}Â°</div>
        </div>
      `;
    }

    // å·¥å…·åˆ‡æ¢
    window.setTool = function(tool) {
      currentTool = tool;
      document.querySelectorAll('.tool-btn').forEach(btn => {
        btn.classList.remove('active');
      });
      event.target.classList.add('active');

      if (tool !== 'select') {
        transformControls.detach();
      }

      updateStatus(`å·¥å…·: ${tool}`);
    }

    // è§†å›¾æ¨¡å¼
    window.setViewMode = function(mode) {
      viewMode = mode;
      parts.forEach(part => {
        if (mode === 'wireframe') {
          part.mesh.material.wireframe = true;
        } else {
          part.mesh.material.wireframe = false;
        }
      });

      document.getElementById('render-mode').textContent =
        mode === 'wireframe' ? 'çº¿æ¡†' :
        mode === 'shaded' ? 'ç€è‰²' : 'ç€è‰²+è¾¹çº¿';

      updateStatus(`è§†å›¾æ¨¡å¼: ${mode}`);
    }

    // é¢„è®¾è§†å›¾
    window.setView = function(view) {
      const distance = 1500;

      switch(view) {
        case 'front':
          camera.position.set(0, 0, distance);
          camera.lookAt(0, 0, 0);
          break;
        case 'top':
          camera.position.set(0, distance, 0);
          camera.lookAt(0, 0, 0);
          break;
        case 'right':
          camera.position.set(distance, 0, 0);
          camera.lookAt(0, 0, 0);
          break;
        case 'iso':
          camera.position.set(distance, distance * 0.8, distance);
          camera.lookAt(0, 0, 0);
          break;
      }

      controls.target.set(0, 0, 0);
      controls.update();
    }

    // é€‚é…è§†å›¾
    window.fitView = function() {
      if (parts.length === 0) return;

      const box = new THREE.Box3();
      parts.forEach(part => box.expandByObject(part.mesh));

      const center = new THREE.Vector3();
      box.getCenter(center);

      const size = new THREE.Vector3();
      box.getSize(size);

      const maxDim = Math.max(size.x, size.y, size.z);
      const distance = maxDim * 1.5;

      camera.position.set(
        center.x + distance,
        center.y + distance * 0.8,
        center.z + distance
      );
      camera.lookAt(center);
      controls.target.copy(center);
      controls.update();

      updateStatus('è§†å›¾å·²é€‚é…');
    }

    // åˆ‡æ¢ç½‘æ ¼
    window.toggleGrid = function() {
      gridHelper.visible = !gridHelper.visible;
      updateStatus(gridHelper.visible ? 'ç½‘æ ¼å·²æ˜¾ç¤º' : 'ç½‘æ ¼å·²éšè—');
    }

    // å±•å¼€å…¨éƒ¨
    window.expandAll = function() {
      updateStatus('æ‰€æœ‰èŠ‚ç‚¹å·²å±•å¼€');
    }

    function updateStatus(text) {
      document.getElementById('status-text').textContent = text;
    }

    // FPSè®¡æ•°å™¨
    let lastTime = performance.now();
    let frames = 0;
    setInterval(() => {
      const now = performance.now();
      const fps = Math.round(frames * 1000 / (now - lastTime));
      document.getElementById('fps-counter').textContent = `${fps} FPS`;
      frames = 0;
      lastTime = now;
    }, 1000);

    function countFrame() {
      frames++;
      requestAnimationFrame(countFrame);
    }
    countFrame();

    // åˆå§‹åŒ–
    initScene();

    // è‡ªåŠ¨åŠ è½½è£…é…
    setTimeout(() => {
      document.getElementById('loading-panel').style.display = 'none';
      updateStatus('å°±ç»ª');
      // è‡ªåŠ¨åŠ è½½
      loadAssembly();
    }, 1000);

    // å¯¼å‡ºç»™å…¨å±€ä½¿ç”¨
    window.scene = scene;
    window.camera = camera;
    window.renderer = renderer;
    window.parts = parts;
  </script>
</body>
</html>
