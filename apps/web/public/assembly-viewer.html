<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>PID 3Dè£…é…å¯è§†åŒ–</title>
  <style>
    body { margin: 0; overflow: hidden; font-family: Arial; }
    #container { width: 100vw; height: 100vh; }
    #info {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 15px;
      border-radius: 8px;
      font-size: 14px;
      max-width: 300px;
    }
    #info h3 { margin: 0 0 10px 0; }
    #info .stat { margin: 5px 0; }
    #controls {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.7);
      padding: 10px 20px;
      border-radius: 8px;
      color: white;
    }
    button {
      background: #4CAF50;
      border: none;
      color: white;
      padding: 8px 16px;
      margin: 0 5px;
      border-radius: 4px;
      cursor: pointer;
    }
    button:hover { background: #45a049; }
  </style>
</head>
<body>
  <div id="container"></div>
  <div id="info">
    <h3>ğŸ”§ PID â†’ 3D è£…é…</h3>
    <div class="stat">é›¶ä»¶æ•°: <span id="partCount">-</span></div>
    <div class="stat">è¿æ¥æ•°: <span id="connCount">-</span></div>
    <div class="stat">å†²çª: <span id="conflicts">-</span></div>
    <div class="stat" style="margin-top:10px; font-size:11px; opacity:0.8">
      ğŸ–±ï¸ å·¦é”®æ—‹è½¬ | å³é”®å¹³ç§» | æ»šè½®ç¼©æ”¾
    </div>
  </div>
  <div id="controls">
    <button onclick="resetCamera()">é‡ç½®è§†è§’</button>
    <button onclick="toggleWireframe()">çº¿æ¡†æ¨¡å¼</button>
    <button onclick="toggleAxes()">åæ ‡è½´</button>
  </div>

  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
    }
  }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    let scene, camera, renderer, controls;
    let meshes = [];
    let axesHelper;
    let wireframeMode = false;

    init();
    loadAssembly();
    animate();

    function init() {
      // åœºæ™¯
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x1a1a2e);

      // ç›¸æœº
      camera = new THREE.PerspectiveCamera(
        50,
        window.innerWidth / window.innerHeight,
        1,
        5000
      );
      camera.position.set(600, 400, 600);
      camera.lookAt(200, 0, 0);

      // æ¸²æŸ“å™¨
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      document.getElementById('container').appendChild(renderer.domElement);

      // æ§åˆ¶å™¨
      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.target.set(200, 0, 0);

      // ç¯å…‰
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);

      const dirLight1 = new THREE.DirectionalLight(0xffffff, 0.8);
      dirLight1.position.set(500, 500, 500);
      dirLight1.castShadow = true;
      scene.add(dirLight1);

      const dirLight2 = new THREE.DirectionalLight(0xffffff, 0.4);
      dirLight2.position.set(-500, 200, -500);
      scene.add(dirLight2);

      // ç½‘æ ¼åœ°é¢
      const gridHelper = new THREE.GridHelper(1000, 20, 0x444444, 0x222222);
      gridHelper.position.y = -150;
      scene.add(gridHelper);

      // åæ ‡è½´
      axesHelper = new THREE.AxesHelper(300);
      scene.add(axesHelper);

      // çª—å£è°ƒæ•´
      window.addEventListener('resize', onWindowResize);
    }

    async function loadAssembly() {
      try {
        // å°è¯•ä»åŒç›®å½•åŠ è½½
        const response = await fetch('./assembly.json');
        if (response.ok) {
          const data = await response.json();
          renderAssembly(data);
          return;
        }
      } catch (e) {
        console.log('å°è¯•æœ¬åœ°æ–‡ä»¶...', e);
      }

      // å¦‚æœå¤±è´¥,ä½¿ç”¨åµŒå…¥æ•°æ®åˆ›å»ºç®€å•è£…é…
      createSimpleAssembly();
    }

    function createSimpleAssembly() {
      console.log('åˆ›å»ºç®€å•è£…é…ç¤ºä¾‹...');

      // é˜€é—¨
      const valveGeo = new THREE.BoxGeometry(150, 100, 100);
      const valveMat = new THREE.MeshStandardMaterial({
        color: 0x4a7c9e,
        metalness: 0.5,
        roughness: 0.5
      });
      const valve = new THREE.Mesh(valveGeo, valveMat);
      valve.name = 'V-001';
      valve.position.set(0, 0, 0);
      valve.castShadow = true;
      scene.add(valve);
      meshes.push(valve);

      // æ³•å…°1
      const flangeGeo = new THREE.CylinderGeometry(75, 75, 20, 32);
      const flangeMat = new THREE.MeshStandardMaterial({
        color: 0xf5a623,
        metalness: 0.5,
        roughness: 0.5
      });
      const flange1 = new THREE.Mesh(flangeGeo, flangeMat);
      flange1.name = 'FL-001';
      flange1.position.set(150, 0, 0);
      flange1.castShadow = true;
      scene.add(flange1);
      meshes.push(flange1);

      // ç®¡é“
      const pipeGeo = new THREE.CylinderGeometry(25, 25, 200, 32);
      const pipeMat = new THREE.MeshStandardMaterial({
        color: 0x7f8c8d,
        metalness: 0.5,
        roughness: 0.5
      });
      const pipe = new THREE.Mesh(pipeGeo, pipeMat);
      pipe.name = 'P-001';
      pipe.position.set(170, 0, 0);
      pipe.rotation.z = Math.PI / 2;
      pipe.castShadow = true;
      scene.add(pipe);
      meshes.push(pipe);

      // æ³•å…°2
      const flange2 = new THREE.Mesh(flangeGeo, flangeMat);
      flange2.name = 'FL-002';
      flange2.position.set(370, 0, 0);
      flange2.castShadow = true;
      scene.add(flange2);
      meshes.push(flange2);

      // æ·»åŠ èºæ “
      const boltGeo = new THREE.CylinderGeometry(8, 8, 60, 16);
      const boltMat = new THREE.MeshStandardMaterial({
        color: 0x8fce00,
        metalness: 0.7,
        roughness: 0.3
      });

      // æ³•å…°1çš„èºæ “ (4ä¸ª)
      const positions1 = [
        [155, 90, 0],
        [155, -90, 0],
        [155, 0, 90],
        [155, 0, -90]
      ];
      positions1.forEach((pos, i) => {
        const bolt = new THREE.Mesh(boltGeo, boltMat);
        bolt.name = `BOLT-1-${i+1}`;
        bolt.position.set(...pos);
        bolt.castShadow = true;
        scene.add(bolt);
        meshes.push(bolt);
      });

      // æ³•å…°2çš„èºæ “ (4ä¸ª)
      const positions2 = [
        [375, 90, 0],
        [375, -90, 0],
        [375, 0, 90],
        [375, 0, -90]
      ];
      positions2.forEach((pos, i) => {
        const bolt = new THREE.Mesh(boltGeo, boltMat);
        bolt.name = `BOLT-2-${i+1}`;
        bolt.position.set(...pos);
        bolt.castShadow = true;
        scene.add(bolt);
        meshes.push(bolt);
      });

      // æ›´æ–°ç»Ÿè®¡
      document.getElementById('partCount').textContent = '4';
      document.getElementById('connCount').textContent = '2';
      document.getElementById('conflicts').textContent = '0 (å·²è‡ªåŠ¨ä¿®å¤)';

      console.log('âœ… ç®€å•è£…é…åˆ›å»ºå®Œæˆ');
    }

    function renderAssembly(jsonData) {
      // æ¸…ç©ºç°æœ‰mesh
      meshes.forEach(m => scene.remove(m));
      meshes = [];

      const loader = new THREE.ObjectLoader();

      // åŠ è½½åœºæ™¯å¯¹è±¡
      const object = loader.parse(jsonData);

      // éå†æ‰€æœ‰å­å¯¹è±¡
      object.traverse((child) => {
        if (child.isMesh) {
          child.castShadow = true;
          child.receiveShadow = true;
          meshes.push(child);
        }
      });

      scene.add(object);

      // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
      const children = object.children || [];
      const partCount = children.filter(c =>
        c.name && (c.name.startsWith('V-') || c.name.startsWith('P-') || c.name.startsWith('FL-'))
      ).length;
      const connCount = Math.floor(children.filter(c =>
        c.name && c.name.startsWith('CONN-')
      ).length / 5);

      document.getElementById('partCount').textContent = partCount;
      document.getElementById('connCount').textContent = connCount;
      document.getElementById('conflicts').textContent = '0 (å·²è‡ªåŠ¨ä¿®å¤)';

      console.log('âœ… è£…é…åŠ è½½å®Œæˆ:', { é›¶ä»¶æ•°: partCount, è¿æ¥æ•°: connCount });
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    window.resetCamera = function() {
      camera.position.set(600, 400, 600);
      controls.target.set(200, 0, 0);
      controls.update();
    };

    window.toggleWireframe = function() {
      wireframeMode = !wireframeMode;
      meshes.forEach(mesh => {
        if (mesh.material) {
          mesh.material.wireframe = wireframeMode;
        }
      });
    };

    window.toggleAxes = function() {
      axesHelper.visible = !axesHelper.visible;
    };
  </script>
</body>
</html>