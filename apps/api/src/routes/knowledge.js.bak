const express = require('express');
const router = express.Router();
const multer = require('multer');
const { authenticate } = require('../middleware/auth');
const KnowledgeController = require('../controllers/KnowledgeController');
const db = require('../config/database');

// é…ç½®æ–‡ä»¶ä¸Šä¼ 
const upload = multer({
  storage: multer.memoryStorage(),
  limits: { fileSize: 100 * 1024 * 1024 },
  fileFilter: (req, file, cb) => {
    try {
      file.originalname = Buffer.from(file.originalname, 'latin1').toString('utf8');
    } catch (e) {
      console.error('[æ–‡ä»¶ä¸Šä¼ ] æ–‡ä»¶åç¼–ç è½¬æ¢å¤±è´¥:', e.message);
    }
    cb(null, true);
  }
});

// è·¯ç”±å®šä¹‰
router.get('/bases', authenticate, KnowledgeController.getKnowledgeBases);
router.post('/bases', authenticate, KnowledgeController.createKnowledgeBase);
router.put('/bases/:id', authenticate, KnowledgeController.updateKnowledgeBase);
router.delete('/bases/:id', authenticate, KnowledgeController.deleteKnowledgeBase);
router.get('/documents', KnowledgeController.getDocuments);
router.post('/documents/upload', authenticate, upload.single('file'), KnowledgeController.uploadDocument);
router.post('/batch-upload', upload.single('file'), KnowledgeController.uploadDocument);
router.post('/documents/upload-extract', upload.single('file'), KnowledgeController.uploadDocument);
router.delete('/documents/:id', authenticate, KnowledgeController.deleteDocument);

// æ™ºèƒ½é—®ç­”
router.post('/chat', authenticate, upload.array('files', 10), async (req, res) => {
  try {
    const { question, scope, history } = req.body;
    const files = req.files;
    const userId = req.user.id;

    console.log('[æ™ºèƒ½é—®ç­”] æ”¶åˆ°é—®é¢˜:', question);

    // 1. å°è¯•å‘é‡æœç´¢
    let vectorContext = '';
    let sources = [];

    try {
      const VectorService = require('../services/knowledge/VectorService');
      const searchResult = await VectorService.search(question, {
        limit: 3,
        kb_id: scope
      });

      if (searchResult.success && searchResult.data.length > 0) {
        console.log(`[æ™ºèƒ½é—®ç­”] æ‰¾åˆ°${searchResult.data.length}ä¸ªç›¸å…³æ–‡æ¡£ç‰‡æ®µ`);

        vectorContext = '\n\nä»¥ä¸‹æ˜¯ç›¸å…³çŸ¥è¯†åº“å†…å®¹ï¼š\n';
        searchResult.data.forEach((item, idx) => {
          vectorContext += `\n[æ¥æº${idx + 1}] ${item.document_name || 'æœªçŸ¥æ–‡æ¡£'}\n${item.text || item.content}\n`;
          sources.push({
            id: idx + 1,
            document_name: item.document_name,
            score: item.score
          });
        });
      } else {
        console.log('[æ™ºèƒ½é—®ç­”] å‘é‡åº“æ— ç›¸å…³å†…å®¹ï¼Œä½¿ç”¨é€šç”¨çŸ¥è¯†å›ç­”');
      }
    } catch (error) {
      console.error('[æ™ºèƒ½é—®ç­”] å‘é‡æ£€ç´¢å¤±è´¥:', error.message);
    }

    // 2. å¤„ç†ä¸Šä¼ æ–‡ä»¶
    let fileContext = '';
    if (files && files.length > 0) {
      const DocumentParserService = require('../services/document/DocumentParserService');
      const parser = new DocumentParserService();

      for (let i = 0; i < files.length; i++) {
        const file = files[i];
        try {
          const content = await parser.parseDocument(file.buffer, file.mimetype, file.originalname);
          if (content && content.trim()) {
            fileContext += `\n\nã€é™„ä»¶ ${i + 1}: ${file.originalname}ã€‘\n${content.substring(0, 5000)}\n`;
          }
        } catch (error) {
          console.error(`[æ™ºèƒ½é—®ç­”] æå–æ–‡ä»¶å†…å®¹å¤±è´¥: ${file.originalname}`, error.message);
        }
      }
    }

    // 3. æ„å»ºç®€æ´æç¤ºè¯
    const UnifiedLLMService = require('../services/llm/UnifiedLLMService');

    let userPrompt = question;
    if (vectorContext || fileContext) {
      userPrompt = `${vectorContext}${fileContext}\n\né—®é¢˜ï¼š${question}\n\nè¯·åŸºäºä¸Šè¿°å†…å®¹ç®€æ´å›ç­”ã€‚`;
    }

    const response = await UnifiedLLMService.generate(userPrompt, {
      temperature: 0.7,
      max_tokens: 500
    });

    res.json({
      success: true,
      data: {
        answer: response.content,
        sources: sources,
        mode: sources.length > 0 ? 'rag' : 'llm',
        outputFiles: [],
        metadata: {
          provider: response.provider,
          model: response.model,
          latency: `${response.latency}ms`
        }
      }
    });
  } catch (error) {
    console.error('[æ™ºèƒ½é—®ç­”] é”™è¯¯:', error);
    res.status(500).json({
      success: false,
      message: error.message || 'æ™ºèƒ½é—®ç­”å¤±è´¥'
    });
  }
});

// å®¡æ ¸ç›¸å…³
router.get('/review', authenticate, async (req, res) => {
  try {
    const { page = 1, pageSize = 10, status = 'pending' } = req.query;
    const offset = (page - 1) * pageSize;

    let query = db('knowledge_review').where('status', status);
    const countResult = await query.clone().count('* as count');
    const total = parseInt(countResult[0].count);

    const list = await query
      .select('*')
      .orderBy('upload_time', 'desc')
      .limit(pageSize)
      .offset(offset);

    res.json({
      success: true,
      data: {
        list,
        pagination: { page: parseInt(page), pageSize: parseInt(pageSize), total }
      }
    });
  } catch (error) {
    console.error('[å†…å®¹å®¡æ ¸] é”™è¯¯:', error);
    res.status(500).json({ success: false, message: 'è·å–å®¡æ ¸åˆ—è¡¨å¤±è´¥', error: error.message });
  }
});

router.post('/review/:id', authenticate, async (req, res) => {
  try {
    const { id } = req.params;
    const { approved, comment } = req.body;
    const userId = req.user.id;

    await db('knowledge_review')
      .where('id', id)
      .update({
        status: approved ? 'approved' : 'rejected',
        reviewer_id: userId,
        review_time: db.fn.now(),
        review_comment: comment || '',
        updated_at: db.fn.now()
      });

    if (approved) {
      const review = await db('knowledge_review').where('id', id).first();
      if (review && review.document_id) {
        await db('knowledge_documents')
          .where('id', review.document_id)
          .update({ status: 'published', published_at: db.fn.now(), updated_at: db.fn.now() });
      }
    }

    res.json({ success: true, message: approved ? 'å®¡æ ¸é€šè¿‡' : 'å®¡æ ¸æ‹’ç»' });
  } catch (error) {
    console.error('[å†…å®¹å®¡æ ¸] é”™è¯¯:', error);
    res.status(500).json({ success: false, message: 'å®¡æ ¸æ“ä½œå¤±è´¥', error: error.message });
  }
});

// ç‰ˆæœ¬ç®¡ç†
router.get('/documents/:id/versions', authenticate, KnowledgeController.getDocumentVersions);
router.post('/documents/:id/versions', authenticate, upload.single('file'), KnowledgeController.uploadNewVersion);
router.put('/documents/:id/versions/:versionId/activate', authenticate, KnowledgeController.switchDocumentVersion);

// è¯­ä¹‰æœç´¢
router.post('/search/semantic', authenticate, async (req, res) => {
  try {
    const { query, kb_id, doc_ids, top_k = 5, threshold = 0.7 } = req.body;

    if (!query) {
      return res.status(400).json({ success: false, message: 'è¯·è¾“å…¥æœç´¢å†…å®¹' });
    }

    const KnowledgeService = require('../services/system/KnowledgeService');
    const service = new KnowledgeService();

    const result = await service.semanticSearch(query, {
      kb_id, doc_ids, top_k, threshold, userId: req.user.id
    });

    if (result.success) {
      res.json(result);
    } else {
      res.status(400).json(result);
    }
  } catch (error) {
    console.error('[è¯­ä¹‰æœç´¢] é”™è¯¯:', error);
    res.status(500).json({ success: false, message: 'æœç´¢å¤±è´¥', error: error.message });
  }
});

// é‡æ–°å¤„ç†æ–‡æ¡£
router.post('/documents/:id/revectorize', authenticate, async (req, res) => {
  try {
    const { id } = req.params;

    await db('knowledge_documents')
      .where({ id })
      .update({ vectorization_status: 'processing', vectorization_error: null, updated_at: db.fn.now() });

    setImmediate(async () => {
      try {
        const KnowledgeService = require('../services/system/KnowledgeService');
        const service = new KnowledgeService();
        await service.vectorizeDocument(id);

        await db('knowledge_documents')
          .where({ id })
          .update({
            vectorization_status: 'completed',
            vectorization_time: db.fn.now(),
            vector_status: 'completed',
            vector_indexed_at: db.fn.now(),
            updated_at: db.fn.now()
          });
      } catch (error) {
        console.error(`[é‡æ–°å‘é‡åŒ–] å¤±è´¥:`, error);
        await db('knowledge_documents')
          .where({ id })
          .update({ vectorization_status: 'failed', vectorization_error: error.message, updated_at: db.fn.now() });
      }
    });

    res.json({ success: true, message: 'å‘é‡åŒ–ä»»åŠ¡å·²æäº¤' });
  } catch (error) {
    console.error('[é‡æ–°å‘é‡åŒ–] é”™è¯¯:', error);
    res.status(500).json({ success: false, message: 'æäº¤å¤±è´¥', error: error.message });
  }
});

router.post('/documents/:id/reextract-graph', authenticate, async (req, res) => {
  try {
    const { id } = req.params;

    await db('knowledge_documents')
      .where({ id })
      .update({ graph_extraction_status: 'processing', graph_extraction_error: null, updated_at: db.fn.now() });

    setImmediate(async () => {
      try {
        const KnowledgeService = require('../services/system/KnowledgeService');
        const service = new KnowledgeService();
        await service.extractGraph(id);

        await db('knowledge_documents')
          .where({ id })
          .update({
            graph_extraction_status: 'completed',
            graph_extraction_time: db.fn.now(),
            graph_status: 'completed',
            graph_indexed_at: db.fn.now(),
            updated_at: db.fn.now()
          });
      } catch (error) {
        console.error(`[é‡æ–°æå–å›¾è°±] å¤±è´¥:`, error);
        await db('knowledge_documents')
          .where({ id })
          .update({ graph_extraction_status: 'failed', graph_extraction_error: error.message, updated_at: db.fn.now() });
      }
    });

    res.json({ success: true, message: 'å›¾è°±æå–ä»»åŠ¡å·²æäº¤' });
  } catch (error) {
    console.error('[é‡æ–°æå–å›¾è°±] é”™è¯¯:', error);
    res.status(500).json({ success: false, message: 'æäº¤å¤±è´¥', error: error.message });
  }
});

router.post('/documents/:id/reprocess', authenticate, async (req, res) => {
  try {
    const { id } = req.params;

    await db('knowledge_documents')
      .where({ id })
      .update({
        vectorization_status: 'processing',
        graph_extraction_status: 'processing',
        vectorization_error: null,
        graph_extraction_error: null,
        updated_at: db.fn.now()
      });

    setImmediate(async () => {
      try {
        const KnowledgeService = require('../services/system/KnowledgeService');
        const service = new KnowledgeService();

        await service.vectorizeDocument(id);
        await service.extractGraph(id);
      } catch (error) {
        console.error(`[é‡æ–°å¤„ç†] å¤±è´¥:`, error);
      }
    });

    res.json({ success: true, message: 'æ–‡æ¡£é‡æ–°å¤„ç†ä»»åŠ¡å·²æäº¤' });
  } catch (error) {
    console.error('[é‡æ–°å¤„ç†] é”™è¯¯:', error);
    res.status(500).json({ success: false, message: 'æäº¤å¤±è´¥', error: error.message });
  }
});

// ä¸‹è½½æ–‡æ¡£
router.get('/documents/:id/download', async (req, res) => {
  try {
    const { id } = req.params;

    const document = await db('knowledge_documents').where({ id }).first();

    if (!document) {
      return res.status(404).json({ success: false, message: 'æ–‡æ¡£ä¸å­˜åœ¨' });
    }

    const MinioService = require('../services/utils/MinioService');
    const stream = await MinioService.getObject('knowledge-documents', document.minio_path);

    res.setHeader('Content-Type', document.file_type || 'application/octet-stream');
    res.setHeader('Content-Disposition', `attachment; filename="${encodeURIComponent(document.name)}"`);

    stream.pipe(res);
  } catch (error) {
    console.error('[æ–‡æ¡£ä¸‹è½½] é”™è¯¯:', error);
    res.status(500).json({ success: false, message: 'ä¸‹è½½å¤±è´¥', error: error.message });
  }
});

// é¢„è§ˆæ–‡æ¡£ - åŸæ–‡ä»¶ä¸ä¿®æ”¹
router.get('/documents/:id/preview', async (req, res) => {
  try {
    const { id } = req.params;

    const document = await db('knowledge_documents').where({ id }).first();

    if (!document) {
      return res.status(404).json({ success: false, message: 'æ–‡æ¡£ä¸å­˜åœ¨' });
    }

    const MinioService = require('../services/utils/MinioService');
    const stream = await MinioService.getObject('knowledge-documents', document.minio_path);

    res.setHeader('Content-Type', document.file_type || 'application/pdf');
    res.setHeader('Content-Disposition', `inline; filename="${encodeURIComponent(document.name)}"`);
    res.setHeader('Access-Control-Allow-Origin', '*');

    stream.pipe(res);
  } catch (error) {
    console.error('[æ–‡æ¡£é¢„è§ˆ] é”™è¯¯:', error);
    res.status(500).json({ success: false, message: 'é¢„è§ˆå¤±è´¥', error: error.message });
  }
});

// Officeæ–‡æ¡£é¢„è§ˆ - ä½¿ç”¨Google Docs Vieweré¢„è§ˆåŸå§‹æ–‡ä»¶
router.get('/documents/:id/office-preview', async (req, res) => {
  try {
    const { id } = req.params;

    const document = await db('knowledge_documents').where({ id }).first();

    if (!document) {
      return res.status(404).json({ success: false, message: 'æ–‡æ¡£ä¸å­˜åœ¨' });
    }

    const fileType = document.file_type || '';
    const fileName = document.name || '';

    // PPTæ–‡æ¡£ - æå–å¹»ç¯ç‰‡ä¸ºå›¾ç‰‡é¢„è§ˆ
    if (fileType.includes('powerpoint') || fileType.includes('officedocument.presentation') || fileName.endsWith('.pptx') || fileName.endsWith('.ppt')) {
      try {
        const MinioService = require('../services/utils/MinioService');
        const stream = await MinioService.getObject('knowledge-documents', document.minio_path);

        const chunks = [];
        for await (const chunk of stream) {
          chunks.push(chunk);
        }
        const buffer = Buffer.concat(chunks);

        // ä½¿ç”¨JSZipæå–PPTXå†…å®¹
        const JSZip = require('jszip');
        const zip = await JSZip.loadAsync(buffer);

        // æå–æ‰€æœ‰å›¾ç‰‡å’Œåª’ä½“æ–‡ä»¶
        const imageFiles = [];
        const slideRelFiles = [];

        // æ‰¾åˆ°æ‰€æœ‰å¹»ç¯ç‰‡å…³ç³»æ–‡ä»¶
        for (const [path, file] of Object.entries(zip.files)) {
          if (path.startsWith('ppt/slides/_rels/') && path.endsWith('.xml.rels')) {
            slideRelFiles.push({ path, file });
          }
        }

        // æå–åª’ä½“æ–‡ä»¶
        for (const [path, file] of Object.entries(zip.files)) {
          if (path.startsWith('ppt/media/') && !file.dir) {
            const ext = path.split('.').pop().toLowerCase();
            if (['png', 'jpg', 'jpeg', 'gif', 'bmp', 'svg', 'emf', 'wmf'].includes(ext)) {
              const content = await file.async('base64');
              const mimeType = ext === 'svg' ? 'image/svg+xml' : `image/${ext === 'jpg' ? 'jpeg' : ext}`;
              imageFiles.push({
                name: path.split('/').pop(),
                data: `data:${mimeType};base64,${content}`,
                path
              });
            }
          }
        }

        console.log(`[PPTé¢„è§ˆ] æ‰¾åˆ° ${imageFiles.length} ä¸ªåª’ä½“æ–‡ä»¶`);

        // è¯»å–å¹»ç¯ç‰‡XMLæ¥è·å–æ–‡æœ¬å†…å®¹
        const slides = [];
        for (let i = 1; i <= 100; i++) {
          const slidePath = `ppt/slides/slide${i}.xml`;
          if (zip.files[slidePath]) {
            const slideXml = await zip.files[slidePath].async('text');

            // ç®€å•æå–æ–‡æœ¬å†…å®¹
            const textMatches = slideXml.match(/<a:t>([^<]+)<\/a:t>/g) || [];
            const texts = textMatches.map(m => m.replace(/<\/?a:t>/g, '').trim()).filter(t => t);

            slides.push({
              number: i,
              texts,
              images: imageFiles.filter((_, idx) => Math.floor(idx / (imageFiles.length / slides.length + 1)) === i - 1)
            });
          } else {
            break;
          }
        }

        console.log(`[PPTé¢„è§ˆ] è§£æäº† ${slides.length} å¼ å¹»ç¯ç‰‡`);

        // ç”ŸæˆHTMLå¹»ç¯ç‰‡é¢„è§ˆ
        const slidesHtml = slides.map((slide, idx) => `
          <div class="slide" data-slide="${idx}" style="${idx === 0 ? 'display:block;' : 'display:none;'}">
            <div class="slide-number">å¹»ç¯ç‰‡ ${slide.number} / ${slides.length}</div>
            <div class="slide-content">
              ${slide.images.map(img => `<img src="${img.data}" alt="å›¾ç‰‡" />`).join('')}
              ${slide.texts.map(text => `<p>${text}</p>`).join('')}
            </div>
          </div>
        `).join('');

        const html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${fileName}</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      user-select: none !important;
      box-sizing: border-box;
    }
    body {
      font-family: 'Microsoft YaHei', Arial, sans-serif;
      background: #1a1a1a;
      overflow: hidden;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }
    .slideshow {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #2a2a2a;
      position: relative;
    }
    .slide {
      width: 90%;
      max-width: 1200px;
      height: 80vh;
      background: white;
      padding: 40px;
      box-shadow: 0 10px 50px rgba(0,0,0,0.5);
      overflow-y: auto;
      position: relative;
    }
    .slide-number {
      position: absolute;
      top: 10px;
      right: 20px;
      background: rgba(0,0,0,0.6);
      color: white;
      padding: 5px 15px;
      border-radius: 20px;
      font-size: 14px;
    }
    .slide-content {
      display: flex;
      flex-direction: column;
      gap: 20px;
    }
    .slide-content img {
      max-width: 100%;
      height: auto;
      display: block;
      margin: 0 auto;
      pointer-events: none;
    }
    .slide-content p {
      font-size: 18px;
      line-height: 1.8;
      color: #333;
      margin: 10px 0;
    }
    .controls {
      background: #1a1a1a;
      padding: 20px;
      display: flex;
      justify-content: center;
      gap: 20px;
      align-items: center;
    }
    button {
      background: #4CAF50;
      color: white;
      border: none;
      padding: 12px 30px;
      font-size: 16px;
      border-radius: 5px;
      cursor: pointer;
      transition: all 0.3s;
      pointer-events: auto;
      user-select: auto !important;
    }
    button:hover {
      background: #45a049;
      transform: translateY(-2px);
    }
    button:disabled {
      background: #666;
      cursor: not-allowed;
      transform: none;
    }
    .progress {
      color: white;
      font-size: 16px;
      min-width: 150px;
      text-align: center;
    }
  </style>
  <script>
    document.addEventListener('contextmenu', e => e.preventDefault());
    document.addEventListener('copy', e => e.preventDefault());
    document.addEventListener('keydown', e => {
      if (e.ctrlKey || e.metaKey) {
        if (['c', 'a', 's', 'p', 'u'].includes(e.key.toLowerCase())) {
          e.preventDefault();
        }
      }
      if (e.key === 'F12') e.preventDefault();

      // é”®ç›˜å¯¼èˆª
      if (e.key === 'ArrowLeft') prevSlide();
      if (e.key === 'ArrowRight') nextSlide();
    });

    let currentSlide = 0;
    const totalSlides = ${slides.length};

    function showSlide(n) {
      const slides = document.querySelectorAll('.slide');
      if (n < 0) n = totalSlides - 1;
      if (n >= totalSlides) n = 0;

      slides.forEach((slide, idx) => {
        slide.style.display = idx === n ? 'block' : 'none';
      });

      currentSlide = n;
      document.getElementById('progress').textContent = \`å¹»ç¯ç‰‡ \${n + 1} / \${totalSlides}\`;
      document.getElementById('prevBtn').disabled = n === 0;
      document.getElementById('nextBtn').disabled = n === totalSlides - 1;
    }

    function nextSlide() {
      showSlide(currentSlide + 1);
    }

    function prevSlide() {
      showSlide(currentSlide - 1);
    }

    window.onload = () => showSlide(0);
  </script>
</head>
<body>
  <div class="slideshow">
    ${slidesHtml}
  </div>
  <div class="controls">
    <button id="prevBtn" onclick="prevSlide()">â—€ ä¸Šä¸€é¡µ</button>
    <div class="progress" id="progress">å¹»ç¯ç‰‡ 1 / ${slides.length}</div>
    <button id="nextBtn" onclick="nextSlide()">ä¸‹ä¸€é¡µ â–¶</button>
  </div>
</body>
</html>
        `;

        res.setHeader('Content-Type', 'text/html; charset=utf-8');
        res.send(html);
        console.log(`[PPTé¢„è§ˆ] æˆåŠŸç”ŸæˆHTMLå¹»ç¯ç‰‡é¢„è§ˆ: ${fileName}`);
        return;

      } catch (pptError) {
        console.error(`[PPTé¢„è§ˆ] ç”Ÿæˆé¢„è§ˆå¤±è´¥:`, pptError);

        const html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>${fileName}</title>
  <style>
    * { user-select: none !important; }
    body {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      margin: 0;
      font-family: 'Microsoft YaHei', Arial, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    }
    .message {
      text-align: center;
      padding: 60px;
      background: white;
      border-radius: 16px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.3);
      max-width: 500px;
    }
    h2 {
      color: #667eea;
      margin-bottom: 20px;
      font-size: 32px;
    }
    p {
      color: #666;
      line-height: 1.8;
      font-size: 16px;
    }
    .icon {
      font-size: 80px;
      margin-bottom: 20px;
    }
    .error {
      background: #ffebee;
      padding: 15px;
      border-radius: 8px;
      margin-top: 20px;
      color: #c62828;
      font-size: 14px;
      text-align: left;
    }
  </style>
</head>
<body>
  <div class="message">
    <div class="icon">ğŸ“Š</div>
    <h2>PPTé¢„è§ˆå¤±è´¥</h2>
    <p><strong>${fileName}</strong></p>
    <p style="margin-top: 20px;">æ— æ³•ç”Ÿæˆå¹»ç¯ç‰‡é¢„è§ˆ</p>
    <div class="error">${pptError.message}</div>
  </div>
</body>
</html>
        `;

        res.setHeader('Content-Type', 'text/html; charset=utf-8');
        res.send(html);
        return;
      }
    }

    // Wordæ–‡æ¡£
    if (fileType.includes('word') || fileType.includes('officedocument.wordprocessing') || fileName.endsWith('.docx')) {
      const MinioService = require('../services/utils/MinioService');
      const stream = await MinioService.getObject('knowledge-documents', document.minio_path);

      const chunks = [];
      for await (const chunk of stream) {
        chunks.push(chunk);
      }
      const buffer = Buffer.concat(chunks);

      const mammoth = require('mammoth');
      const result = await mammoth.convertToHtml({ buffer });

      const html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>${fileName}</title>
  <style>
    * { user-select: none !important; }
    body {
      font-family: 'Microsoft YaHei', Arial, sans-serif;
      padding: 40px;
      max-width: 900px;
      margin: 0 auto;
      background: #f5f5f5;
    }
    .content {
      background: white;
      padding: 40px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }
    img { max-width: 100%; pointer-events: none; }
    p { line-height: 1.8; }
  </style>
  <script>
    document.addEventListener('contextmenu', e => e.preventDefault());
    document.addEventListener('copy', e => e.preventDefault());
    document.addEventListener('keydown', e => {
      if (e.ctrlKey || e.metaKey) {
        if (['c', 'a', 's', 'p', 'u'].includes(e.key.toLowerCase())) e.preventDefault();
      }
      if (e.key === 'F12') e.preventDefault();
    });
  </script>
</head>
<body>
  <div class="content">${result.value}</div>
</body>
</html>
      `;

      res.setHeader('Content-Type', 'text/html; charset=utf-8');
      res.send(html);
      return;
    }

    // Excelæ–‡æ¡£
    if (fileType.includes('excel') || fileType.includes('officedocument.spreadsheet') || fileName.endsWith('.xlsx') || fileName.endsWith('.xls')) {
      const MinioService = require('../services/utils/MinioService');
      const stream = await MinioService.getObject('knowledge-documents', document.minio_path);

      const chunks = [];
      for await (const chunk of stream) {
        chunks.push(chunk);
      }
      const buffer = Buffer.concat(chunks);

      const XLSX = require('xlsx');
      const workbook = XLSX.read(buffer, { type: 'buffer' });
      let htmlContent = '';

      workbook.SheetNames.forEach((sheetName) => {
        const worksheet = workbook.Sheets[sheetName];
        const htmlTable = XLSX.utils.sheet_to_html(worksheet);
        htmlContent += `<h2>Sheet: ${sheetName}</h2>${htmlTable}`;
      });

      const html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>${fileName}</title>
  <style>
    * { user-select: none !important; }
    body { font-family: 'Microsoft YaHei', Arial, sans-serif; padding: 20px; background: #f5f5f5; }
    table { border-collapse: collapse; width: 100%; background: white; margin: 20px 0; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
    th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
    th { background-color: #f2f2f2; font-weight: bold; }
    tr:nth-child(even) { background-color: #f9f9f9; }
    h2 { color: #333; margin-top: 30px; }
  </style>
  <script>
    document.addEventListener('contextmenu', e => e.preventDefault());
    document.addEventListener('copy', e => e.preventDefault());
    document.addEventListener('keydown', e => {
      if (e.ctrlKey || e.metaKey) {
        if (['c', 'a', 's', 'p', 'u'].includes(e.key.toLowerCase())) e.preventDefault();
      }
      if (e.key === 'F12') e.preventDefault();
    });
  </script>
</head>
<body>
  <h1>${fileName}</h1>
  ${htmlContent}
</body>
</html>
      `;

      res.setHeader('Content-Type', 'text/html; charset=utf-8');
      res.send(html);
      return;
    }

    res.status(400).json({ success: false, message: 'ä¸æ”¯æŒçš„æ–‡ä»¶æ ¼å¼' });

  } catch (error) {
    console.error('[Officeé¢„è§ˆ] é”™è¯¯:', error);
    res.status(500).json({ success: false, message: 'Officeæ–‡æ¡£é¢„è§ˆå¤±è´¥', error: error.message });
  }
});

module.exports = router;
